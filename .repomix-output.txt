This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-10T14:33:03.892Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  3rd-party/
    posthog/
      app-router-server-setup.mdx
      index.mdx
  api-reference.md
  architecture.md
  deployment.md
  development-guide.md
  getting-started.md
  overview.md
  README.md
  user-guide.md
messages/
  en.json
  he.json
public/
  404.html
  Ads.txt
  file.svg
  globe.svg
  index.html
  logo_O.svg
  logo.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    actions/
      dictation.ts
    api/
      auth/
        [...nextauth]/
          route.ts
      dictation/
        create/
          route.ts
        drafts/
          route.ts
        edit/
          [id]/
            route.ts
        generate-content/
          route.ts
        latest/
          route.ts
        list/
          route.ts
        play/
          [id]/
            route.ts
        tts/
          route.ts
        upload/
          route.ts
    auth/
      error/
        page.tsx
      reset-password/
        page.tsx
        ResetPasswordForm.tsx
      signin/
        page.tsx
        SignInForm.tsx
      signup/
        page.tsx
        SignUpForm.tsx
      update-email/
        page.tsx
      verify-email/
        page.tsx
      actions.ts
    dictation/
      create/
        page.tsx
      edit/
        [id]/
          page.tsx
      play/
        [id]/
          bubble/
          quiz-game/
            page.tsx
          writer/
          writer-game/
            page.tsx
          page.tsx
    privacy-policy/
      page.tsx
    profile/
      edit/
        page.tsx
      actions.ts
      page.tsx
      ProfileForm.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    Adsense/
      AdUnit.tsx
    dictation/
      AdvancedQuizOptions.tsx
      DictationForm.tsx
      FileUpload.tsx
      GameCard.tsx
      GameCardClient.tsx
      GameContainer.tsx
      GameHeader.tsx
      GameOverView.tsx
      GameView.tsx
      LanguageSelector.tsx
      LatestGames.tsx
      QuizGameClient.tsx
      QuizGameView.tsx
      WordPairDisplay.tsx
      WordPairList.tsx
      WriterGameClient.tsx
      WriterGameContainer.tsx
    Footer/
      index.tsx
    Header/
      index.tsx
    ui/
      AdBlockDetector.tsx
      button.tsx
      card.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      popover.tsx
      select.tsx
      skeleton.tsx
      sonner.tsx
      spinner.tsx
      switch.tsx
      textarea.tsx
      tooltip.tsx
    LanguageSelector.tsx
    PostHogProvider.tsx
    Providers.tsx
  hooks/
    usePostHogUser.tsx
  i18n/
    config.ts
    request.ts
  lib/
    server/
      tts.ts
    auth.ts
    client-constants.ts
    fileUtils.ts
    firebase-admin.ts
    firebase.ts
    game.ts
    locale.ts
    metadata.ts
    openai.ts
    posthog-utils.ts
    posthog.ts
    server-constants.ts
    storage.ts
    types.ts
    utils.ts
  types/
    rtl-detect.d.ts
  middleware.ts
.firebaserc
.gitignore
components.json
database.rules.json
eslint.config.mjs
firebase.json
firestore.indexes.json
firestore.rules
next.config.js
next.config.ts
package.json
postcss.config.mjs
README.md
storage.rules
tailwind.config.ts
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/3rd-party/posthog/app-router-server-setup.mdx">
For the app router, we can initialize the `posthog-node` SDK once with a `PostHogClient` function, and import it into files.

This enables us to send events and fetch data from PostHog on the server – without making client-side requests.

```js
// app/posthog.js
import { PostHog } from 'posthog-node'

export default function PostHogClient() {
  const posthogClient = new PostHog(process.env.NEXT_PUBLIC_POSTHOG_KEY, {
    host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
    flushAt: 1,
    flushInterval: 0
  })
  return posthogClient
}
```

> **Note:** Because server-side functions in Next.js can be short-lived, we set `flushAt` to `1` and `flushInterval` to `0`. 
> - `flushAt` sets how many capture calls we should flush the queue (in one batch). 
> - `flushInterval` sets how many milliseconds we should wait before flushing the queue. 
> Setting them to the lowest number ensures events are sent immediately and not batched. We also need to call `await posthog.shutdown()` once done.

To use this client, we import it into our pages and call it with the `PostHogClient` function:

```js
import Link from 'next/link'
import PostHogClient from '../posthog'

export default async function About() {

  const posthog = PostHogClient()
  const flags = await posthog.getAllFlags(
    'user_distinct_id' // replace with a user's distinct ID
  );
  await posthog.shutdown()

  return (
    <main>
      <h1>About</h1>
      <Link href="/">Go home</Link>
      { flags['main-cta'] &&
        <Link href="http://posthog.com/">Go to PostHog</Link>
      }
    </main>
  )
}
```
</file>

<file path="docs/3rd-party/posthog/index.mdx">
---
title: Next.js
icon: >-
  https://res.cloudinary.com/dmukukwp6/image/upload/posthog.com/contents/images/docs/integrate/frameworks/nextjs.svg
features:
  eventCapture: true
  userIdentification: true
  autoCapture: true
  sessionRecording: true
  featureFlags: true
  groupAnalytics: true
  surveys: true
  llmObservability: true
  errorTracking: true
---

PostHog makes it easy to get data about traffic and usage of your [Next.js](https://nextjs.org/) app. Integrating PostHog into your site enables analytics about user behavior, custom events capture, session recordings, feature flags, and more.

This guide walks you through integrating PostHog into your Next.js app using the [React](/docs/libraries/react) and the [Node.js](/docs/libraries/node) SDKs.

> You can see a working example of this integration in our [Next.js demo app](https://github.com/PostHog/posthog-js/tree/master/playground/nextjs).

Next.js has both client and server-side rendering, as well as pages and app routers. We'll cover all of these options in this guide.

## Prerequisites

To follow this guide along, you need:

1. A PostHog instance (either [Cloud](https://app.posthog.com/signup) or [self-hosted](/docs/self-host))
2. A Next.js application

## Client-side setup

import NextJSInstall from "../../integrate/_snippets/nextjs/install-nextjs.mdx"

<NextJSInstall />

### Accessing PostHog using the provider

PostHog can then be accessed throughout your Next.js app by using the `usePostHog` hook. See the [React SDK docs](/docs/libraries/react) for examples of how to use:

- [`posthog-js` functions like custom event capture, user identification, and more.](/docs/libraries/react#using-posthog-js-functions)
- [Feature flags including variants and payloads.](/docs/libraries/react#feature-flags)

You can also read [the full `posthog-js` documentation](/docs/libraries/js/features) for all the usable functions.

## Server-side analytics

Server-side rendering enables you to render pages on the server instead of the client. This can be useful for SEO, performance, and user experience.

To integrate PostHog into your Next.js app on the server-side, you can use the [Node SDK](/docs/libraries/node).

First, install the `posthog-node` library:

```shell
yarn add posthog-node
# or
npm install --save posthog-node
```

### Router-specific instructions

import Tab from "components/Tab"
import AppRouterServerSetup from "./_snippets/app-router-server-setup.mdx"
import PagesRouterServerSetup from "./_snippets/pages-router-server-setup.mdx"

<Tab.Group tabs={[
    'App router', 
    'Pages router']}>
    <Tab.List>
        <Tab>App router</Tab>
        <Tab>Pages router</Tab>
    </Tab.List>
    <Tab.Panels>
        <Tab.Panel>
            <AppRouterServerSetup />
        </Tab.Panel>
        <Tab.Panel>
            <PagesRouterServerSetup />
        </Tab.Panel>
    </Tab.Panels>
</Tab.Group>

### Server-side Configuration

NextJS overrides the default `fetch` behaviour on the server to introduce their own cache. Posthog will ignore that cache by default, as this is also NextJS's default behavior to any fetch call.

You can override that configuration when initializing Posthog if you wish, but make sure you understand the pros/cons of using NextJS's cache and are aware that you might get cached results rather than the actual result our server would be returning - for feature flags, for example.

```tsx
posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY, {
  // ... your configuration
  fetch_options: {
    cache: 'force-cache', // Use NextJS cache
    next_options: {       // Passed to the `next` option for `fetch`
      revalidate: 60,     // Cache for 60 seconds
      tags: ['posthog'],  // Can be used with NextJS `revalidateTag` function
    },
  }
})
```

## Configuring a reverse proxy to PostHog

To improve the reliability of client-side tracking and make requests less likely to be intercepted by tracking blockers, you can setup a reverse proxy in Next.js. Read more about deploying a reverse proxy using [Next.js rewrites](/docs/advanced/proxy/nextjs), [Next.js middleware](/docs/advanced/proxy/nextjs-middleware), and [Vercel rewrites](/docs/advanced/proxy/vercel).

## Frequently asked questions

### Does wrapping my app in the PostHog provider de-opt it to client-side rendering?

No. Even though the PostHog provider is a client component, since we pass the `children` prop to it, any component inside the children tree can still be a server component. Next.js creates a boundary between server-run and client-run code. 

The [`use client` reference](https://react.dev/reference/rsc/use-client) says that it "defines the boundary between server and client code on the module dependency tree, not the render tree." It also says that "During render, the framework will server-render the root component and continue through the render tree, opting-out of evaluating any code imported from client-marked code."

Pages router components are client components by default.

### What does wrapping my app in the PostHog provider do?

On top of the standard features like autocapture, custom events, session recording, and more, wrapping your app in the PostHog provider gives you:

1. The `usePostHog`, `useFeatureFlagEnabled`, and other hooks in any component.
2. A PostHog context you can access in any component.
3. The `<PostHogFeature>` component which simplifies feature flag logic.

See the [React SDK docs](/docs/libraries/react) for more details.

### Why use a `useEffect` hook to initialize PostHog?

We want to initialize PostHog when the app is loaded. The [React docs](https://react.dev/learn/synchronizing-with-effects) recommend using a `useEffect` hook to do this:

> Effects let you specify side effects that are caused by rendering itself, rather than by a particular event. 

Technically, you can also use a `window` object check to initialize PostHog. This happens outside the React lifecycle, meaning it happens earlier and it looks like this:

<MultiLanguage>

```js
// app/providers.js
'use client'
import posthog from 'posthog-js'
import { PostHogProvider } from 'posthog-js/react'

if (typeof window !== 'undefined') {
  posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY, {
    api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
    capture_pageview: false // Disable automatic pageview capture, as we capture manually
  })
}

export function PHProvider({ children }) {
  return <PostHogProvider client={posthog}>{children}</PostHogProvider>
}
```

```tsx
// app/providers.tsx
'use client'
import posthog from 'posthog-js'
import { PostHogProvider } from 'posthog-js/react'

if (typeof window !== 'undefined') {
  posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
    api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
    capture_pageview: false // Disable automatic pageview capture, as we capture manually
  })
}

export function PHProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <PostHogProvider client={posthog}>{children}</PostHogProvider>
}
```

</MultiLanguage>

The problem with this is that it can cause a [hydration and/or mismatch error](https://nextjs.org/docs/messages/react-hydration-error) like `Warning: Prop dangerouslySetInnerHTML did not match.`.

### Why does the pageview component need a `useEffect`? 

Using a `useEffect` hook is the simplest way to accurately capture pageviews. Other approaches include:

1. Not using a `useEffect` hook, but this might lead to duplicate page views being tracked if the component re-renders for reasons other than navigation. It might work depending on your implementation. 
2. Using `window.navigation` to track pageviews, but this approach is more complex and is [not supported](https://developer.mozilla.org/en-US/docs/Web/API/Window/navigation) in all browsers. 

## Further reading

- [How to set up Next.js app router analytics, feature flags, and more](/tutorials/nextjs-app-directory-analytics)
- [How to set up Next.js analytics, feature flags, and more](/tutorials/nextjs-analytics)
- [How to set up Next.js A/B tests](/tutorials/nextjs-ab-tests)
</file>

<file path="docs/api-reference.md">
# Dictation Manager API Reference

This document provides details on the API endpoints available in the Dictation Manager application, their request/response formats, and usage examples.

## Base URL

All API endpoints are relative to the base URL of your Dictation Manager installation.

For development: `http://localhost:3000/api`  
For production: `https://your-domain.com/api`

## Authentication

Most API endpoints require authentication. To authenticate requests, you need to:

1. Be logged in to the application (using Firebase Authentication)
2. Session cookies will be automatically included in requests

## API Endpoints

### Dictation Games

#### Get a Dictation Game

Retrieves a single dictation game by ID.

```
GET /dictation/play/{id}
```

**Parameters:**

| Parameter | Type   | Required | Description     |
|-----------|--------|----------|-----------------|
| id        | string | Yes      | Dictation game ID |

**Response:**

```json
{
  "id": "game123",
  "title": "Basic Spanish Vocabulary",
  "description": "Learn common Spanish words",
  "sourceLanguage": "en",
  "targetLanguage": "es",
  "wordPairs": [
    {
      "first": "hello",
      "second": "hola",
      "sentence": "Hello, how are you?"
    },
    // more word pairs...
  ],
  "quizParameters": {
    "globalTimeLimit": 300,
    "globalLivesLimit": 3,
    "activityTimeLimit": 30,
    "quizModeEnabled": false
  },
  "createdAt": "2023-01-15T12:30:45Z",
  "updatedAt": "2023-01-15T14:20:15Z",
  "isPublic": true,
  "playCount": 42
}
```

**Status Codes:**

- `200 OK`: Game retrieved successfully
- `404 Not Found`: Game not found
- `403 Forbidden`: Not authorized to access this game

#### Increment Play Count

Increments the play count for a dictation game.

```
POST /dictation/play/{id}
```

**Parameters:**

| Parameter | Type   | Required | Description     |
|-----------|--------|----------|-----------------|
| id        | string | Yes      | Dictation game ID |

**Response:**

```json
{
  "success": true,
  "playCount": 43
}
```

**Status Codes:**

- `200 OK`: Play count incremented successfully
- `404 Not Found`: Game not found
- `500 Internal Server Error`: Failed to increment play count

#### Create a Dictation Game

Creates a new dictation game.

```
POST /dictation/create
```

**Request Body:**

```json
{
  "title": "Spanish Food Vocabulary",
  "description": "Learn common Spanish food terms",
  "sourceLanguage": "en",
  "targetLanguage": "es",
  "wordPairs": [
    {
      "first": "apple",
      "second": "manzana",
      "sentence": "I eat an apple every day."
    },
    // more word pairs...
  ],
  "quizParameters": {
    "globalTimeLimit": 300,
    "globalLivesLimit": 3,
    "activityTimeLimit": 30,
    "quizModeEnabled": false
  },
  "isPublic": true
}
```

**Response:**

```json
{
  "success": true,
  "gameId": "newgame123",
  "redirect": "/dictation/edit/newgame123"
}
```

**Status Codes:**

- `201 Created`: Game created successfully
- `400 Bad Request`: Invalid request data
- `401 Unauthorized`: Not authenticated
- `500 Internal Server Error`: Failed to create game

#### Update a Dictation Game

Updates an existing dictation game.

```
PUT /dictation/edit/{id}
```

**Parameters:**

| Parameter | Type   | Required | Description     |
|-----------|--------|----------|-----------------|
| id        | string | Yes      | Dictation game ID |

**Request Body:**

Same format as the Create endpoint.

**Response:**

```json
{
  "success": true,
  "gameId": "game123"
}
```

**Status Codes:**

- `200 OK`: Game updated successfully
- `400 Bad Request`: Invalid request data
- `401 Unauthorized`: Not authenticated
- `403 Forbidden`: Not authorized to update this game
- `404 Not Found`: Game not found
- `500 Internal Server Error`: Failed to update game

#### Delete a Dictation Game

Deletes a dictation game.

```
DELETE /dictation/game/{id}
```

**Parameters:**

| Parameter | Type   | Required | Description     |
|-----------|--------|----------|-----------------|
| id        | string | Yes      | Dictation game ID |

**Response:**

```json
{
  "success": true
}
```

**Status Codes:**

- `200 OK`: Game deleted successfully
- `401 Unauthorized`: Not authenticated
- `403 Forbidden`: Not authorized to delete this game
- `404 Not Found`: Game not found
- `500 Internal Server Error`: Failed to delete game

### Content Generation

#### Generate Word Pairs

Generates word pairs using AI.

```
POST /dictation/generate-content
```

**Request Body:**

```json
{
  "sourceLanguage": "en",
  "targetLanguage": "es",
  "topic": "Food and Dining",
  "count": 10,
  "includeExampleSentences": true
}
```

**Response:**

```json
{
  "success": true,
  "wordPairs": [
    {
      "first": "restaurant",
      "second": "restaurante",
      "sentence": "We had dinner at a nice restaurant."
    },
    // more generated word pairs...
  ]
}
```

**Status Codes:**

- `200 OK`: Content generated successfully
- `400 Bad Request`: Invalid request data
- `401 Unauthorized`: Not authenticated
- `429 Too Many Requests`: Rate limit exceeded
- `500 Internal Server Error`: Failed to generate content

### User Data

#### Get User Games

Retrieves all dictation games created by the authenticated user.

```
GET /user/games
```

**Response:**

```json
{
  "games": [
    {
      "id": "game123",
      "title": "Basic Spanish Vocabulary",
      "description": "Learn common Spanish words",
      "sourceLanguage": "en",
      "targetLanguage": "es",
      "wordPairsCount": 15,
      "createdAt": "2023-01-15T12:30:45Z",
      "updatedAt": "2023-01-15T14:20:15Z",
      "isPublic": true,
      "playCount": 42
    },
    // more games...
  ]
}
```

**Status Codes:**

- `200 OK`: Games retrieved successfully
- `401 Unauthorized`: Not authenticated
- `500 Internal Server Error`: Failed to retrieve games

## Error Handling

All API endpoints follow a consistent error response format:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message"
  }
}
```

Common error codes:

- `AUTHENTICATION_REQUIRED`: User is not authenticated
- `PERMISSION_DENIED`: User does not have permission
- `RESOURCE_NOT_FOUND`: Requested resource not found
- `INVALID_REQUEST`: Invalid request data
- `RATE_LIMIT_EXCEEDED`: Too many requests
- `SERVER_ERROR`: Internal server error

## Rate Limiting

API endpoints are subject to rate limiting to prevent abuse. The current limits are:

- Regular API calls: 100 requests per minute
- Content generation: 10 requests per minute

When rate limited, the API will respond with a `429 Too Many Requests` status code.

## Webhooks (Future Feature)

Webhook support for game creation and updates is planned for a future release.

## SDK (Future Feature)

A JavaScript SDK for easier integration is planned for a future release.
</file>

<file path="docs/architecture.md">
# Dictation Manager Architecture

This document provides an overview of the Dictation Manager application's technical architecture, explaining the design decisions, component structure, and data flow.

## Technology Stack

Dictation Manager is built using the following technologies:

- **Frontend Framework**: Next.js 14 with App Router
- **UI Library**: React 18
- **Type System**: TypeScript
- **Styling**: Tailwind CSS with Shadcn UI components
- **State Management**: React Context and custom hooks
- **Database**: Firebase Firestore
- **Authentication**: Firebase Authentication
- **Storage**: Firebase Storage
- **API**: Next.js API Routes
- **Internationalization**: next-intl
- **Deployment**: Vercel (or Firebase Hosting)

## Application Architecture

### High-Level Architecture

The application follows a modern client-server architecture built on Next.js:

```
┌─────────────────────────────────────┐
│              Client                 │
│  ┌─────────────┐    ┌─────────────┐ │
│  │  Next.js    │    │  React      │ │
│  │  Pages      │◄───┤  Components │ │
│  └─────────────┘    └─────────────┘ │
└───────────┬─────────────────────────┘
            │
            ▼
┌─────────────────────────────────────┐
│           Server/API                │
│  ┌─────────────┐    ┌─────────────┐ │
│  │  Next.js    │    │  Firebase   │ │
│  │  API Routes │◄───┤  Admin SDK  │ │
│  └─────────────┘    └─────────────┘ │
└───────────┬─────────────────────────┘
            │
            ▼
┌─────────────────────────────────────┐
│           Data Storage              │
│  ┌─────────────┐    ┌─────────────┐ │
│  │  Firestore  │    │  Firebase   │ │
│  │  Database   │    │  Storage    │ │
│  └─────────────┘    └─────────────┘ │
└─────────────────────────────────────┘
```

### Directory Structure

The application follows a feature-based directory structure:

```
src/
├── app/                # Next.js App Router files
│   ├── api/            # API routes
│   │   ├── auth/       # Authentication API
│   │   └── dictation/  # Dictation game API
│   ├── dictation/      # Dictation game pages
│   │   ├── create/     # Create game page
│   │   ├── edit/       # Edit game page
│   │   └── play/       # Play game page
│   └── ...             # Other app pages
├── components/         # React components
│   ├── dictation/      # Dictation-specific components
│   │   ├── DictationForm.tsx
│   │   ├── GameCard.tsx
│   │   ├── GameContainer.tsx
│   │   ├── GameView.tsx
│   │   └── ...
│   ├── ui/             # UI components (shadcn)
│   └── ...             # Other components
├── lib/                # Utility functions and libraries
│   ├── firebase.ts     # Firebase configuration
│   ├── types.ts        # TypeScript types
│   └── ...
├── i18n/               # Internationalization config
└── ...
```

## Component Architecture

### Core Components

1. **GameContainer**: The main container for dictation games
   - Manages game state and lifecycle
   - Handles play count tracking
   - Toggles between pre-game and active game states

2. **GameView**: The active game play component
   - Implements game mechanics (time, lives, scoring)
   - Handles user input and validation
   - Displays game progress and results

3. **DictationForm**: Form for creating and editing dictation games
   - Manages form state and validation
   - Handles API interactions for saving, updating, and deleting games
   - Provides content generation functionality

4. **WordPairList**: Component for managing word pairs
   - Allows adding, editing, and removing word pairs
   - Supports file upload for bulk word pair creation

5. **GameCard**: Display card for dictation games in lists
   - Shows game metadata and statistics
   - Provides action buttons for play, edit, delete

## Data Flow

### Creating a Dictation Game

1. User fills out the DictationForm with game details
2. Form data is validated using client-side validation
3. On submission, data is sent to `/api/dictation/create` endpoint
4. Server validates the data and creates a new document in Firestore
5. User is redirected to their games list or the edit page

### Playing a Dictation Game

1. User selects a game to play, navigating to `/dictation/play/[id]`
2. Server fetches game data from Firestore and passes it to the client
3. GameContainer initializes the game state
4. When user starts the game, play count is incremented via API call
5. GameView handles the gameplay logic, tracking progress and score
6. On game completion, results are displayed to the user

## Database Schema

### Firestore Collections

- **users**: User profile information
  ```
  users/{userId}
  {
    displayName: string,
    email: string,
    photoURL?: string,
    createdAt: timestamp
  }
  ```

- **dictation_games**: Dictation game data
  ```
  dictation_games/{gameId}
  {
    userId: string,
    title: string,
    description?: string,
    sourceLanguage: string,
    targetLanguage: string,
    wordPairs: [
      {
        first: string,
        second: string,
        sentence?: string,
        secondAudioUrl?: string
      }
    ],
    quizParameters: {
      globalTimeLimit: number,
      globalLivesLimit: number,
      activityTimeLimit: number,
      quizModeEnabled: boolean
    },
    createdAt: timestamp,
    updatedAt: timestamp,
    isPublic: boolean,
    playCount: number
  }
  ```

## Authentication Flow

1. User signs in using Firebase Authentication (email/password or Google provider)
2. Upon successful authentication, a session cookie is set
3. Protected routes and API endpoints verify the authentication state
4. User-specific data is fetched based on the authenticated user's ID

## API Endpoints

### Dictation Game Endpoints

- **GET /api/dictation/play/{id}**
  - Retrieves a dictation game by ID
  - Returns game data or 404 if not found

- **POST /api/dictation/play/{id}**
  - Increments the play count for a dictation game
  - Returns success status

- **POST /api/dictation/create**
  - Creates a new dictation game
  - Requires authentication
  - Returns the created game ID

- **POST /api/dictation/generate-content**
  - Generates word pairs using AI (OpenAI integration)
  - Requires authentication
  - Returns generated content

## Performance Considerations

- Server-side rendering for initial page load
- Client-side navigation for subsequent page transitions
- Firebase SDK initialized only when needed
- React.memo() for performance-critical components
- Next.js image optimization for media assets

## Security Considerations

- Firebase Authentication for user management
- Firestore security rules to restrict data access
- API routes validated server-side
- Content sanitization for user-generated content
- Environment variables for sensitive configuration

## Internationalization

The application uses next-intl for internationalization:

- Translation files stored in the `messages/` directory
- Language selector for user preferences
- Server-side rendering respects user's language preference
- Date and number formatting adapted to locale

## Future Architecture Considerations

- Migration to Firebase v9 modular SDK
- Implementation of a service worker for offline support
- Server Components optimization
- Streaming SSR for improved performance
- Implementing WebSockets for real-time features
</file>

<file path="docs/deployment.md">
# Dictation Manager Deployment Guide

This guide provides detailed instructions for deploying the Dictation Manager application to various platforms.

## Table of Contents

- [Deployment Prerequisites](#deployment-prerequisites)
- [Deploying to Vercel](#deploying-to-vercel)
- [Deploying to Firebase Hosting](#deploying-to-firebase-hosting)
- [Deploying to a Custom Server](#deploying-to-a-custom-server)
- [Environment Configuration](#environment-configuration)
- [Post-Deployment Verification](#post-deployment-verification)
- [Continuous Integration/Continuous Deployment](#continuous-integrationcontinuous-deployment)

## Deployment Prerequisites

Before deploying the Dictation Manager application, ensure you have:

1. A complete and tested build of the application
2. A Firebase project set up with:
   - Firestore database
   - Firebase Authentication
   - Firebase Storage (optional, for file uploads)
3. Required environment variables documented and ready
4. Domain name (optional, but recommended for production)

## Deploying to Vercel

Vercel is the recommended deployment platform for Next.js applications like Dictation Manager.

### Steps for Vercel Deployment

1. **Prepare Your Repository**:
   - Ensure your code is pushed to a Git repository (GitHub, GitLab, or Bitbucket)
   - Make sure the repository contains a working `package.json` file with build scripts

2. **Connect with Vercel**:
   - Create an account on [Vercel](https://vercel.com) if you don't have one
   - Click "Import Project" from the Vercel dashboard
   - Select your Git provider and authorize Vercel to access your repositories
   - Select the Dictation Manager repository

3. **Configure Project Settings**:
   - Set the Framework Preset to "Next.js"
   - Configure the build settings:
     - Build Command: `next build`
     - Output Directory: `.next`
   - Add environment variables (see [Environment Configuration](#environment-configuration))

4. **Deploy**:
   - Click "Deploy"
   - Vercel will build and deploy your application
   - Once completed, your application will be available at a Vercel-provided URL

5. **Custom Domain** (Optional):
   - Go to "Settings" > "Domains"
   - Add your custom domain
   - Follow the instructions to configure DNS settings

### Automatic Deployments

With Vercel, any commits pushed to your main branch will automatically trigger a new deployment.

## Deploying to Firebase Hosting

Firebase Hosting is another excellent option, especially since the application already uses Firebase services.

### Steps for Firebase Hosting Deployment

1. **Install Firebase CLI**:
   ```bash
   npm install -g firebase-tools
   ```

2. **Login to Firebase**:
   ```bash
   firebase login
   ```

3. **Initialize Firebase Hosting**:
   ```bash
   firebase init hosting
   ```
   
   During initialization:
   - Select your Firebase project
   - Set the public directory to "out"
   - Configure as a single-page app
   - Set up automatic builds and deploys (optional)

4. **Update Next.js Config**:
   Add the following to your `next.config.js` file:
   ```javascript
   module.exports = {
     output: 'export',
     images: {
       unoptimized: true,
     },
     // ... other config options
   }
   ```

5. **Build the Application**:
   ```bash
   npm run build
   ```

6. **Deploy to Firebase**:
   ```bash
   firebase deploy --only hosting
   ```

7. **Custom Domain** (Optional):
   - Go to the Firebase console > Hosting
   - Connect your custom domain and verify ownership
   - Set up DNS records as instructed

## Deploying to a Custom Server

For more control, you can deploy the Dictation Manager to your own server.

### Steps for Custom Server Deployment

1. **Prepare Your Server**:
   - Set up a server with Node.js (version 18 or higher)
   - Install a process manager like PM2:
     ```bash
     npm install -g pm2
     ```
   - Set up Nginx or Apache as a reverse proxy (recommended)

2. **Deploy Your Code**:
   - Clone your repository to the server:
     ```bash
     git clone https://github.com/yourusername/dictation-manager.git
     cd dictation-manager
     ```
   - Install dependencies:
     ```bash
     npm install --production
     ```
   - Build the application:
     ```bash
     npm run build
     ```

3. **Set Up Environment Variables**:
   - Create a `.env` file with the required variables

4. **Start the Application with PM2**:
   ```bash
   pm2 start npm --name "dictation-manager" -- start
   ```

5. **Configure Nginx as a Reverse Proxy**:
   Create a configuration file in `/etc/nginx/sites-available/dictation-manager`:
   ```nginx
   server {
       listen 80;
       server_name yourdomain.com;

       location / {
           proxy_pass http://localhost:3000;
           proxy_http_version 1.1;
           proxy_set_header Upgrade $http_upgrade;
           proxy_set_header Connection 'upgrade';
           proxy_set_header Host $host;
           proxy_cache_bypass $http_upgrade;
       }
   }
   ```

6. **Enable the Site and Restart Nginx**:
   ```bash
   ln -s /etc/nginx/sites-available/dictation-manager /etc/nginx/sites-enabled/
   nginx -t
   systemctl restart nginx
   ```

7. **Set Up SSL with Certbot** (recommended):
   ```bash
   certbot --nginx -d yourdomain.com
   ```

## Environment Configuration

The following environment variables are required for deployment:

### Firebase Configuration

```
# Firebase Client SDK (for browser)
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project_id.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_project_id.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# Firebase Admin SDK (for server)
FIREBASE_ADMIN_PROJECT_ID=your_project_id
FIREBASE_ADMIN_CLIENT_EMAIL=your_client_email
FIREBASE_ADMIN_PRIVATE_KEY=your_private_key
```

### Authentication Configuration

```
NEXTAUTH_URL=https://yourdomain.com
NEXTAUTH_SECRET=your_random_secret_key
```

### Additional Configuration

```
# OpenAI API Key (for content generation)
OPENAI_API_KEY=your_openai_api_key

# Analytics (optional)
NEXT_PUBLIC_ANALYTICS_ID=your_analytics_id
```

## Post-Deployment Verification

After deploying the application, verify that:

1. **The application loads correctly**:
   - Homepage opens without errors
   - Navigation works as expected

2. **Authentication works**:
   - Users can sign up
   - Users can log in
   - Protected routes are accessible only to authenticated users

3. **Core functionality works**:
   - Creating a dictation game
   - Playing a dictation game
   - Editing a dictation game

4. **API endpoints work**:
   - Test the `/api/dictation/play/{id}` endpoint
   - Test the `/api/dictation/create` endpoint

## Continuous Integration/Continuous Deployment

### GitHub Actions

You can set up CI/CD with GitHub Actions by creating a `.github/workflows/deploy.yml` file:

```yaml
name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run Tests
        run: npm test

      - name: Build
        run: npm run build
        env:
          # Add your environment variables here
          NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
          # ... other env vars

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

### Vercel Integration

Vercel also offers direct integration with GitHub, GitLab, and Bitbucket, which automatically sets up CI/CD:

1. Connect your repository to Vercel
2. Configure the build settings
3. Vercel will automatically deploy on each push to the main branch

## Monitoring and Logging

For production deployments, set up:

1. **Error Tracking**:
   - Consider integrating Sentry or LogRocket

2. **Performance Monitoring**:
   - Use Vercel Analytics or Google Analytics

3. **Server Logs**:
   - Configure server logs to be stored and easily accessible

## Scaling Considerations

As your user base grows:

1. **Firebase Pricing Tiers**:
   - Monitor your Firebase usage and upgrade plans as needed

2. **Caching Strategy**:
   - Implement caching for frequently accessed data

3. **CDN Integration**:
   - Use a CDN for static assets to improve global performance
</file>

<file path="docs/development-guide.md">
# Dictation Manager Development Guide

This guide provides information for developers who want to contribute to or extend the Dictation Manager application.

## Development Environment Setup

### Prerequisites

- Node.js 18.x or higher
- Git
- Firebase account
- Visual Studio Code (recommended) or another IDE
- Basic knowledge of:
  - Next.js
  - React
  - TypeScript
  - Firebase
  - Tailwind CSS

### Setting Up Your Development Environment

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/dictation-manager.git
   cd dictation-manager
   ```

2. Install dependencies:
   ```bash
   npm install
   # or
   yarn install
   # or
   pnpm install
   ```

3. Set up environment variables:
   Copy `.env.example` to `.env.local` and fill in the variables.

4. Start the development server:
   ```bash
   npm run dev
   # or
   yarn dev
   # or
   pnpm dev
   ```

## Project Structure

### Core Directories

- `src/app/` - Next.js App Router pages and API routes
- `src/components/` - React components
- `src/lib/` - Utility functions and types
- `src/i18n/` - Internationalization configuration
- `messages/` - Translation files

### Key Files

- `src/app/layout.tsx` - Root layout component
- `src/lib/types.ts` - TypeScript type definitions
- `src/middleware.ts` - Next.js middleware for authentication and localization
- `firestore.rules` - Firestore security rules
- `storage.rules` - Firebase Storage security rules

## Component Development

### Component Design Principles

1. **Single Responsibility**: Components should have a single responsibility.
2. **Reusability**: Build components that can be reused in multiple contexts.
3. **Prop Typing**: Always define TypeScript interfaces for component props.
4. **Server vs Client Components**: Use server components when possible, add `'use client'` directive only when needed.

### Creating a New Component

1. Determine if the component should be a client or server component.
2. For client components, add the `'use client'` directive at the top of the file.
3. Define a TypeScript interface for the component props.
4. Implement the component using functional component syntax.
5. Add appropriate comments and documentation.

Example:

```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'

interface ExampleComponentProps {
  initialValue: number
  onChange?: (value: number) => void
}

export function ExampleComponent({ 
  initialValue, 
  onChange 
}: ExampleComponentProps) {
  const [value, setValue] = useState(initialValue)
  
  const handleClick = () => {
    const newValue = value + 1
    setValue(newValue)
    if (onChange) {
      onChange(newValue)
    }
  }
  
  return (
    <div className="p-4 border rounded">
      <p>Current value: {value}</p>
      <Button onClick={handleClick}>Increment</Button>
    </div>
  )
}
```

### UI Components

The project uses Shadcn UI components. To add new UI components:

```bash
npx shadcn-ui@latest add [component-name]
```

## State Management

### Local State

Use React's built-in state management:
- `useState` for simple state
- `useReducer` for complex state logic
- `useContext` for shared state across components

### Server-side State

For server-side state and data fetching, use:
- Next.js API routes
- Server components
- React Server Components data fetching

## API Development

### Creating a New API Endpoint

1. Create a new file in the appropriate directory under `src/app/api/`.
2. Implement the necessary HTTP method handlers (GET, POST, etc.).
3. Add proper validation and error handling.
4. Document the endpoint in the API reference.

Example:

```tsx
// src/app/api/example/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'

export async function GET(req: NextRequest) {
  // Check authentication
  const session = await getServerSession()
  if (!session) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
  }
  
  try {
    // Process the request
    const data = { message: 'Example API response' }
    return NextResponse.json(data)
  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' }, 
      { status: 500 }
    )
  }
}
```

## Database Operations

### Firestore Access Patterns

Access Firestore using the Firebase Admin SDK on the server side:

```tsx
import { db } from '@/lib/firebase-admin'

// Get a document
const docRef = db.collection('dictation_games').doc('game-id')
const doc = await docRef.get()
const data = doc.data()

// Create a document
await db.collection('dictation_games').add({
  title: 'New Game',
  createdAt: new Date(),
  // ...other fields
})

// Update a document
await docRef.update({
  title: 'Updated Title'
})

// Delete a document
await docRef.delete()
```

### Security Rules

When modifying data structures, ensure you update the Firestore security rules in `firestore.rules`:

```
service cloud.firestore {
  match /databases/{database}/documents {
    match /dictation_games/{gameId} {
      allow read: if resource.data.isPublic == true || 
                  request.auth.uid == resource.data.userId;
      allow write: if request.auth.uid == resource.data.userId;
    }
  }
}
```

## Authentication

The application uses Firebase Authentication. When working with authenticated routes:

1. On the client side, use the authentication context:
   ```tsx
   'use client'
   import { useAuth } from '@/lib/auth'
   
   export function ProfileButton() {
     const { user, signOut } = useAuth()
     
     if (!user) return null
     
     return (
       <button onClick={signOut}>
         Logout {user.displayName}
       </button>
     )
   }
   ```

2. On the server side, check authentication in API routes:
   ```tsx
   import { auth } from '@/lib/firebase-admin'
   
   // Verify the session cookie
   const idToken = request.cookies.get('session')?.value || ''
   try {
     const decodedToken = await auth.verifyIdToken(idToken)
     const uid = decodedToken.uid
     // Process authenticated request
   } catch (error) {
     // Handle authentication error
   }
   ```

## Internationalization

### Adding New Translations

1. Add new keys to the message files in the `messages/` directory.
2. Use the translation keys in your components:
   ```tsx
   import { useTranslations } from 'next-intl'
   
   export function TranslatedComponent() {
     const t = useTranslations('Namespace')
     
     return <p>{t('key')}</p>
   }
   ```

### Adding a New Language

1. Create a new message file in the `messages/` directory.
2. Update the language configuration in `src/i18n/config.ts`.

## Testing

### Unit Testing

Use Jest and React Testing Library for unit tests:

```tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { ExampleComponent } from './ExampleComponent'

describe('ExampleComponent', () => {
  test('renders correctly', () => {
    render(<ExampleComponent initialValue={5} />)
    expect(screen.getByText('Current value: 5')).toBeInTheDocument()
  })
  
  test('increments value on button click', () => {
    render(<ExampleComponent initialValue={5} />)
    fireEvent.click(screen.getByText('Increment'))
    expect(screen.getByText('Current value: 6')).toBeInTheDocument()
  })
})
```

### Integration Testing

For integration tests, focus on user workflows and component interactions.

## Deployment

### Deploying to Vercel

1. Push your changes to your GitHub repository.
2. Connect your repository to Vercel.
3. Configure the environment variables in the Vercel dashboard.
4. Deploy the application.

### Deploying to Firebase Hosting

1. Build the application:
   ```bash
   npm run build
   ```

2. Initialize Firebase Hosting (if not already done):
   ```bash
   firebase init hosting
   ```

3. Deploy to Firebase:
   ```bash
   firebase deploy --only hosting
   ```

## Contributing

### Pull Request Process

1. Fork the repository and create a new branch for your feature or fix.
2. Implement your changes following the project's coding standards.
3. Add unit tests for new functionality.
4. Update documentation as necessary.
5. Submit a pull request with a clear description of your changes.

### Code Style

The project follows these conventions:

- ESLint for code linting
- Prettier for code formatting
- TypeScript for type safety

Run the linter and formatter before submitting pull requests:

```bash
npm run lint
npm run format
```

## Troubleshooting

### Common Issues

1. **Firebase Authentication Issues**:
   - Check Firebase console for any authentication restrictions.
   - Ensure your API keys and configuration are correct.

2. **API Route Errors**:
   - Check server logs for detailed error messages.
   - Verify authentication state and permissions.

3. **Styling Issues**:
   - Make sure Tailwind classes are correct.
   - Check for conflicts in CSS modules.

### Getting Help

If you're stuck, try:
1. Checking the issue tracker for similar problems
2. Creating a new issue with detailed information
3. Reaching out to other contributors

## Resources

- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://reactjs.org/docs)
- [TypeScript Documentation](https://www.typescriptlang.org/docs)
- [Firebase Documentation](https://firebase.google.com/docs)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [Shadcn UI Documentation](https://ui.shadcn.com)
</file>

<file path="docs/getting-started.md">
# Getting Started with Dictation Manager

This guide will help you set up the Dictation Manager application for development or personal use.

## Prerequisites

Before installing Dictation Manager, ensure you have the following:

- Node.js (version 18 or higher)
- npm, yarn, or pnpm package manager
- Git (for cloning the repository)
- Firebase account (for database and authentication)

## Installation

### 1. Clone the Repository

```bash
git clone https://github.com/AceDZN/dictation-master.git
cd dictation-manager
```

### 2. Install Dependencies

Using npm:
```bash
npm install
```

Using yarn:
```bash
yarn install
```

Using pnpm:
```bash
pnpm install
```

### 3. Configure Firebase

1. Create a new project in the [Firebase Console](https://console.firebase.google.com/)
2. Enable Authentication (Email/Password and Google provider)
3. Create a Firestore database
4. Set up Storage

### 4. Configure Environment Variables

Create a `.env.local` file in the root directory of the project with the following variables:

```
# Firebase Configuration
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_auth_domain
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_storage_bucket
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# Firebase Admin SDK (for server-side operations)
FIREBASE_ADMIN_PROJECT_ID=your_project_id
FIREBASE_ADMIN_CLIENT_EMAIL=your_client_email
FIREBASE_ADMIN_PRIVATE_KEY=your_private_key

# Next Auth Configuration
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your_secret

# Optional: OpenAI API Key (for content generation)
OPENAI_API_KEY=your_openai_api_key
```

To obtain these values:

1. Firebase Web SDK config can be found in your Firebase project settings
2. For the Firebase Admin SDK, create a service account in the Firebase Console and download the JSON file

### 5. Security Rules

Configure Firebase security rules for Firestore and Storage. Sample rules are provided in:

- `firestore.rules` - For Firestore database rules
- `storage.rules` - For Firebase Storage rules

Deploy these rules using the Firebase CLI:

```bash
firebase deploy --only firestore:rules,storage
```

## Running the Application

### Development Mode

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

The application will be available at [http://localhost:3000](http://localhost:3000).

### Production Build

```bash
npm run build
npm start
# or
yarn build
yarn start
# or
pnpm build
pnpm start
```

## Firebase Emulator (Optional)

For local development without affecting your production Firebase instance:

1. Install Firebase CLI:
```bash
npm install -g firebase-tools
```

2. Login to Firebase:
```bash
firebase login
```

3. Start the Firebase emulator:
```bash
firebase emulators:start
```

4. Update your `.env.local` to point to the emulator:
```
NEXT_PUBLIC_FIREBASE_EMULATOR_HOST=localhost
NEXT_PUBLIC_FIREBASE_AUTH_EMULATOR_PORT=9099
NEXT_PUBLIC_FIRESTORE_EMULATOR_PORT=8080
```

## Next Steps

After setting up the application:

1. Create an account through the application
2. Create your first dictation game
3. Explore the features and customize your experience

For detailed usage instructions, refer to the [User Guide](./user-guide.md).
</file>

<file path="docs/overview.md">
# Dictation Manager Overview

## Introduction

Dictation Manager is a web application designed to help language learners practice and improve their language skills through dictation exercises. The application allows users to create custom dictation games with word pairs in different languages, play these games, and track their progress over time.

## Purpose

The main purpose of Dictation Manager is to:

- Facilitate language learning through dictation exercises
- Provide a customizable platform for creating language practice content
- Offer an engaging, gamified experience for reinforcing vocabulary and comprehension
- Support multilingual learning with support for various language pairs

## Key Features

### Game Creation

- Create custom dictation games with unique word pairs
- Support for multiple language pairs (source language to target language)
- Add example sentences for context
- Configure advanced game parameters (time limits, lives, etc.)
- Generate content automatically (via AI integration)
- Import word pairs from files

### Game Management

- Save drafts of games in progress
- Edit existing games
- Delete games
- Make games public or private
- View play statistics

### Game Play

- Interactive dictation exercises
- Gamified experience with hearts (lives), time limits, and scoring
- Progress tracking during gameplay
- Immediate feedback on correct/incorrect answers
- Option to show or hide example sentences
- End-of-game performance summaries with stars and statistics

### User Features

- User authentication and profiles
- Personal collection of created dictation games
- Browse public dictation games

## Target Audience

- Language learners at all levels
- Language teachers creating learning materials
- Educational institutions
- Self-learners looking for interactive language practice

## Technology Stack

Dictation Manager is built with modern web technologies:

- Frontend: Next.js, React, and TypeScript
- UI: Tailwind CSS, Shadcn UI components
- Backend: Next.js API routes
- Database: Firebase Firestore
- Authentication: Firebase Auth
- Internationalization: next-intl

## Next Steps

For installation and setup instructions, see the [Getting Started](./getting-started.md) guide.
For detailed usage instructions, refer to the [User Guide](./user-guide.md).
</file>

<file path="docs/README.md">
# Dictation Manager Documentation

Welcome to the Dictation Manager documentation. This application is designed to help users create, manage, and practice language dictation exercises.

## Table of Contents

- [Overview](./overview.md) - Introduction to the Dictation Manager
- [Getting Started](./getting-started.md) - Installation and setup instructions
- [Architecture](./architecture.md) - Technical architecture and design
- [User Guide](./user-guide.md) - Complete user documentation
- [API Reference](./api-reference.md) - API endpoints and usage
- [Development Guide](./development-guide.md) - Guide for developers
- [Deployment](./deployment.md) - Deployment instructions

## Quick Links

- [Creating a Dictation Game](./user-guide.md#creating-a-dictation-game)
- [Playing a Dictation Game](./user-guide.md#playing-a-dictation-game)
- [Managing Word Pairs](./user-guide.md#managing-word-pairs)
- [Configuration Options](./user-guide.md#configuration-options)

## Contributing

See the [Development Guide](./development-guide.md) for information on how to contribute to this project.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="docs/user-guide.md">
# Dictation Manager User Guide

This comprehensive guide will help you navigate and use all the features of the Dictation Manager application.

## Table of Contents

- [Getting Started](#getting-started)
- [Account Management](#account-management)
- [Creating a Dictation Game](#creating-a-dictation-game)
- [Managing Word Pairs](#managing-word-pairs)
- [Playing a Dictation Game](#playing-a-dictation-game)
- [Managing Your Games](#managing-your-games)
- [Advanced Features](#advanced-features)

## Getting Started

### Accessing the Application

1. Open your web browser and navigate to the Dictation Manager website.
2. You'll be presented with the home page where you can sign in or create an account.

### Navigation

The main navigation menu provides access to:

- Home: The landing page with featured dictation games
- My Games: Your personal collection of created dictation games
- Create: Create a new dictation game
- Profile: Your user profile and settings

## Account Management

### Creating an Account

1. Click "Sign Up" from the navigation menu or home page.
2. Enter your email and create a password, or use Google Sign-In.
3. Complete your profile by adding a display name.

### Managing Your Profile

1. Click on your profile icon in the top-right corner.
2. Select "Profile" from the dropdown menu.
3. Here you can update your display name, profile picture, and other settings.

## Creating a Dictation Game

### Basic Game Creation

1. Click "Create" in the navigation menu.
2. Fill out the basic information:
   - **Title**: A descriptive title for your dictation game
   - **Description** (optional): Additional details about the game
   - **Source Language**: The language of the words to be dictated
   - **Target Language**: The language learners are practicing

### Adding Word Pairs

A word pair consists of:
- A word or phrase in the source language
- Its translation in the target language
- An optional example sentence

To add word pairs manually:

1. In the word pair section, enter the source language word/phrase.
2. Enter the corresponding target language translation.
3. Optionally, add an example sentence that uses the word.
4. Click "Add Another Pair" to add more word pairs.
5. Use the "Remove" button to delete any unwanted pairs.

### Importing Word Pairs

To import multiple word pairs at once:

1. Click the "Import from File" button in the word pairs section.
2. Select a CSV or Excel file with your word pairs.
3. The file should have columns for the source word, target word, and optional example sentence.
4. After uploading, review the imported pairs and make any necessary adjustments.

### Using AI Content Generation

To generate content automatically:

1. Enter your dictation game's title, source language, and target language.
2. Click the "Generate Content" button.
3. Specify the number of word pairs you want to generate.
4. The AI will create word pairs with example sentences based on your parameters.
5. Review and edit the generated content as needed.

### Setting Game Parameters

Configure the gameplay experience with these settings:

1. **Global Time Limit**: Total time allowed for the entire game (in seconds)
2. **Lives**: Number of incorrect answers allowed before game over
3. **Activity Time Limit**: Time allowed for each individual word (in seconds)
4. **Quiz Mode**: Enable for a stricter gameplay experience

### Saving Your Game

You have two options for saving:

- **Save Draft**: Saves your progress without publishing the game
- **Publish**: Makes the game available for play

You can also set the game's visibility:
- **Public**: Everyone can see and play your game
- **Private**: Only you can access the game

## Managing Word Pairs

### Editing Word Pairs

1. Click on any existing word pair to modify its content.
2. Update the source word, target word, or example sentence.
3. Changes are saved automatically when you click outside the field.

### Rearranging Word Pairs

1. Use the drag handle icon to rearrange the order of word pairs.
2. Drag a word pair to its new position in the list.

### Bulk Operations

- **Delete All**: Removes all word pairs (with confirmation)
- **Import**: Imports word pairs from a file (can append to existing pairs)

## Playing a Dictation Game

### Starting a Game

1. Navigate to the game you want to play.
2. Click the "Play" button to open the game screen.
3. Review the game details and word pairs.
4. Click "Start Game" when you're ready.

### Gameplay

1. A word from the source language is displayed.
2. Type the correct translation in the target language.
3. Press Enter or click "Submit" to check your answer.
4. If correct, you'll move to the next word.
5. If incorrect, you'll lose a heart (life).
6. The timer shows remaining time for the current word and overall game.

### Game Controls

- **Pause Button**: Temporarily stops the game
- **Example Toggle**: Shows/hides example sentences (if available)
- **Progress Bar**: Shows your progress through the word pairs
- **Hearts Display**: Shows remaining lives
- **Timer**: Shows remaining time

### Game Results

When the game ends (all words completed, time expired, or all lives lost):

1. A results screen displays your performance:
   - Stars earned (0-3 based on performance)
   - Accuracy percentage
   - Time taken
   - Hearts remaining
   - Words completed

2. You can choose to:
   - Play Again: Restart the same game
   - Exit: Return to the game listing

## Managing Your Games

### Viewing Your Games

1. Click "My Games" in the navigation menu.
2. All games you've created will be displayed with:
   - Title and description
   - Source and target languages
   - Number of word pairs
   - Play count
   - Creation date

### Editing a Game

1. From "My Games," find the game you want to edit.
2. Click the "Edit" button.
3. Make your changes to the game settings, word pairs, or parameters.
4. Click "Save" to update the game.

### Deleting a Game

1. From "My Games," find the game you want to delete.
2. Click the "Delete" button.
3. Confirm the deletion when prompted.

## Advanced Features

### Filtering and Searching

1. Use the search bar to find specific games by title or description.
2. Filter games by language pair, creation date, or popularity.

### Sharing Games

1. Open the game you want to share.
2. Click the "Share" button.
3. Copy the generated link or use the social media buttons to share directly.
4. Note: Only public games can be shared.

### Keyboard Shortcuts

During gameplay, you can use these keyboard shortcuts:
- **Enter**: Submit your answer
- **Escape**: Pause the game
- **Tab**: Move to the next input field

### Game Analytics

For your own games, you can view:
- Total play count
- Average completion rate
- User ratings (if enabled)

## Troubleshooting

### Common Issues

1. **Game won't load**: Check your internet connection and try refreshing the page.
2. **Can't save a game**: Ensure you've filled out all required fields.
3. **Import problems**: Check that your file is in the correct format (CSV or Excel).

### Getting Help

If you encounter any issues:
1. Check the FAQ section on the website.
2. Use the "Contact Support" form for personalized assistance.
3. Visit the community forum to see if others have experienced similar issues.
</file>

<file path="messages/en.json">
{
  "HomePage": {
    "title": "Master Languages Through Interactive Dictation",
    "description": "Create personalized dictation games to enhance vocabulary learning across multiple languages. Perfect for educators and language learners.",
    "createGame": "Create Your First Game",
    "learnMore": "Learn more"
  },
  "LatestGames": {
    "title": "Latest Dictation Games",
    "description": "Check out the most recent public dictation games created by our community."
    },
  "Profile": {
    "title": "Profile",
    "editProfile": "Edit Profile",
    "publishedGames": "Published Games",
    "draftGames": "Draft Games",
    "noPublishedGames": "You haven't published any games yet.",
    "noDraftGames": "You don't have any drafts.",
    "editTitle": "Edit Profile",
    "firstName": "First Name",
    "lastName": "Last Name",
    "profileImage": "Profile Image",
    "change": "Change",
    "saveChanges": "Save Changes",
    "saving": "Saving...",
    "updateSuccess": "Profile updated successfully!",
    "updateError": "Failed to update profile",
    "imageSizeError": "Image size should be less than 5MB"
  },
  "Language": {
    "select": "Select Language",
    "en": "English",
    "he": "Hebrew",
    "languages": {
      "English": "English",
      "Hebrew": "Hebrew",
      "Spanish": "Spanish",
      "French": "French",
      "German": "German",
      "Italian": "Italian",
      "Portuguese": "Portuguese",
      "Russian": "Russian",
      "Chinese": "Chinese",
      "Japanese": "Japanese",
      "Korean": "Korean",
      "Arabic": "Arabic"
    }
  },
  "Header": {
    "signIn": "Sign in",
    "signOut": "Sign out",
    "profile": "Profile",
    "appName": "Dictation Masters",
    "logoLabel": "Dictation Masters Logo"
  },
  "Dictation": {
    "create": {
      "title": "Create New Dictation",
      "description": "Create a new dictation game by filling out the form below."
    },
    "edit": {
      "title": "Edit Dictation",
      "description": "Edit your dictation game"
    },
    "form": {
      "basicInfo": "Basic Information",
      "title": "Title",
      "titlePlaceholder": "Enter game title",
      "description": "Description",
      "descriptionPlaceholder": "Enter game description",
      "public": "Public",
      "sourceLanguage": "Source Language",
      "targetLanguage": "Target Language",
      "swapLanguages": "Swap languages",
      "wordPairs": "Word Pairs",
      "uploadWordPairs": "Upload Word Pairs",
      "addWordPair": "Add Word Pair",
      "sourceWord": "{language} word",
      "targetWord": "{language} word",
      "exampleSentence": "Example sentence (optional)",
      "advancedOptions": "Advanced Options",
      "advancedMode": "Advanced Mode",
      "quizMode": "Quiz Mode",
      "globalTimeLimit": "Global Time Limit (minutes)",
      "activityTimeLimit": "Activity Time Limit (seconds)",
      "livesLimit": "Lives Limit",
      "cancel": "Cancel",
      "deleteDraft": "Delete Draft",
      "deleting": "Deleting...",
      "saveChanges": "Save Changes",
      "saving": "Saving...",
      "populateData": "Populate Data",
      "generating": "Generating...",
      "saveAsDraft": "Save as Draft",
      "createDictation": "Create Dictation",
      "creating": "Creating...",
      "processingFile": "Processing File..."
    },
    "game": {
      "startGame": "Start Game",
      "startWriterGame": "Writing Mode",
      "startQuizGame": "Quiz Mode",
      "writerGameDescription": "Type the translations for each word",
      "quizGameDescription": "Choose the correct translation from options",
      "translate": "Translate",
      "gameOver": "Game Over!",
      "playAgain": "Play Again",
      "exit": "Exit",
      "timeLeft": "Time Left",
      "progress": "Progress",
      "hearts": "Hearts",
      "words": "words",
      "created": "Created",
      "showExamples": "Show example sentences",
      "hideExamples": "Hide example sentences",
      "back": "Back",
      "playAudio": "Play Audio",
      "retryAudio": "Retry Audio",
      "loading": "Loading..."
    },
    "card": {
      "edit": "Edit",
      "delete": "Delete",
      "play": "Play",
      "words": "{count} words",
      "created": "Created"
    }
  }
}
</file>

<file path="messages/he.json">
{
  "HomePage": {
    "title": "שליטה בשפות באמצעות הכתבה אינטראקטיבית",
    "description": "צור משחקי הכתבה מותאמים אישית כדי לשפר את לימוד אוצר המילים במספר שפות. מושלם למחנכים ולומדי שפות.",
    "createGame": "צור את המשחק הראשון שלך",
    "learnMore": "למד עוד"
  },
  "LatestGames": {
    "title": "משחקי הכתבה אחרונים",
    "description": "בדוק את משחקי ההכתבה הציבוריים האחרונים שנוצרו על ידי הקהילה שלנו."
  },
  "Profile": {
    "title": "פרופיל",
    "editProfile": "ערוך פרופיל",
    "publishedGames": "משחקים שפורסמו",
    "draftGames": "טיוטות משחקים",
    "noPublishedGames": "עדיין לא פרסמת משחקים.",
    "noDraftGames": "אין לך טיוטות.",
    "editTitle": "ערוך פרופיל",
    "firstName": "שם פרטי",
    "lastName": "שם משפחה",
    "profileImage": "תמונת פרופיל",
    "change": "שנה",
    "saveChanges": "שמור שינויים",
    "saving": "שומר...",
    "updateSuccess": "הפרופיל עודכן בהצלחה!",
    "updateError": "עדכון הפרופיל נכשל",
    "imageSizeError": "גודל התמונה צריך להיות פחות מ-5MB"
  },
  "Language": {
    "select": "בחר שפה",
    "en": "אנגלית",
    "he": "עברית",
    "languages": {
      "English": "אנגלית",
      "Hebrew": "עברית",
      "Spanish": "ספרדית",
      "French": "צרפתית",
      "German": "גרמנית",
      "Italian": "איטלקית",
      "Portuguese": "פורטוגזית",
      "Russian": "רוסית",
      "Chinese": "סינית",
      "Japanese": "יפנית",
      "Korean": "קוריאנית",
      "Arabic": "ערבית"
    }
  },
  "Header": {
    "signIn": "התחבר",
    "signOut": "התנתק",
    "profile": "פרופיל",
    "appName": "מאסטר הכתבות",
    "logoLabel": "Dictation Masters Logo"
  },
  "Dictation": {
    "create": {
      "title": "צור הכתבה חדשה",
      "description": "צור משחק הכתבה חדש על ידי מילוי הטופס למטה."
    },
    "edit": {
      "title": "ערוך הכתבה",
      "description": "ערוך את משחק ההכתבה שלך"
    },
    "form": {
      "basicInfo": "מידע בסיסי",
      "title": "כותרת",
      "titlePlaceholder": "הזן כותרת משחק",
      "description": "תיאור",
      "descriptionPlaceholder": "הזן תיאור משחק",
      "public": "ציבורי",
      "sourceLanguage": "שפת מקור",
      "targetLanguage": "שפת יעד",
      "swapLanguages": "החלף שפות",
      "wordPairs": "זוגות מילים",
      "uploadWordPairs": "העלה זוגות מילים",
      "addWordPair": "הוסף זוג מילים",
      "sourceWord": "מילה ב-{language}",
      "targetWord": "מילה ב-{language}",
      "exampleSentence": "משפט לדוגמה (אופציונלי)",
      "advancedOptions": "אפשרויות מתקדמות",
      "advancedMode": "מצב מתקדם",
      "quizMode": "מצב חידון",
      "globalTimeLimit": "מגבלת זמן כללית (דקות)",
      "activityTimeLimit": "מגבלת זמן לפעילות (שניות)",
      "livesLimit": "מגבלת חיים",
      "cancel": "ביטול",
      "deleteDraft": "מחק טיוטה",
      "deleting": "מוחק...",
      "saveChanges": "שמור שינויים",
      "saving": "שומר...",
      "populateData": "מלא נתונים",
      "generating": "מייצר...",
      "saveAsDraft": "שמור כטיוטה",
      "createDictation": "צור הכתבה",
      "creating": "יוצר...",
      "processingFile": "מעבד קובץ..."
    },
    "game": {
      "startGame": "התחל משחק",
      "startWriterGame": "מצב כתיבה",
      "startQuizGame": "מצב חידון",
      "writerGameDescription": "הקלד את התרגומים לכל מילה",
      "quizGameDescription": "בחר את התרגום הנכון מבין האפשרויות",
      "translate": "תרגם",
      "gameOver": "המשחק נגמר!",
      "playAgain": "שחק שוב",
      "exit": "יציאה",
      "timeLeft": "זמן נותר",
      "progress": "התקדמות",
      "hearts": "חיים",
      "words": "מילים",
      "created": "נוצר",
      "showExamples": "הצג משפטי דוגמה",
      "hideExamples": "הסתר משפטי דוגמה",
      "back": "חזרה",
      "playAudio": "נגן שמע",
      "retryAudio": "נסה שוב",
      "loading": "טוען..."
    },
    "card": {
      "edit": "ערוך",
      "delete": "מחק",
      "play": "שחק",
      "words": "{count} מילים",
      "created": "נוצר"
    }
  }
}
</file>

<file path="public/404.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Page Not Found</title>
    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px 16px; border-radius: 3px; }
      #message h3 { color: #888; font-weight: normal; font-size: 16px; margin: 16px 0 12px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>404</h2>
      <h1>Page Not Found</h1>
      <p>The specified file was not found on this website. Please check the URL for mistakes and try again.</p>
      <h3>Why am I seeing this?</h3>
      <p>This page was generated by the Firebase Command-Line Interface. To modify it, edit the <code>404.html</code> file in your project's configured <code>public</code> directory.</p>
    </div>
  </body>
</html>
</file>

<file path="public/Ads.txt">
google.com, pub-7458209475481910, DIRECT, f08c47fec0942fa0
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Welcome to Firebase Hosting</title>
    <!-- update the version number as needed -->
    <script defer src="/__/firebase/11.2.0/firebase-app-compat.js"></script>
    <!-- include only the Firebase features as you need -->
    <script defer src="/__/firebase/11.2.0/firebase-auth-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-database-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-firestore-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-functions-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-messaging-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-storage-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-analytics-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-remote-config-compat.js"></script>
    <script defer src="/__/firebase/11.2.0/firebase-performance-compat.js"></script>
    <!-- 
      initialize the SDK after all desired features are loaded, set useEmulator to false
      to avoid connecting the SDK to running emulators.
    -->
    <script defer src="/__/firebase/init.js?useEmulator=true"></script>
    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px; border-radius: 3px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>Welcome</h2>
      <h1>Firebase Hosting Setup Complete</h1>
      <p>You're seeing this because you've successfully setup Firebase Hosting. Now it's time to go build something extraordinary!</p>
      <a target="_blank" href="https://firebase.google.com/docs/hosting/">Open Hosting Documentation</a>
    </div>
    <p id="load">Firebase SDK Loading&hellip;</p>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const loadEl = document.querySelector('#load');
        // // 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥
        // // The Firebase SDK is initialized and available here!
        //
        // firebase.auth().onAuthStateChanged(user => { });
        // firebase.database().ref('/path/to/ref').on('value', snapshot => { });
        // firebase.firestore().doc('/foo/bar').get().then(() => { });
        // firebase.functions().httpsCallable('yourFunction')().then(() => { });
        // firebase.messaging().requestPermission().then(() => { });
        // firebase.storage().ref('/path/to/ref').getDownloadURL().then(() => { });
        // firebase.analytics(); // call to activate
        // firebase.analytics().logEvent('tutorial_completed');
        // firebase.performance(); // call to activate
        //
        // // 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥
        try {
          let app = firebase.app();
          let features = [
            'auth', 
            'database', 
            'firestore',
            'functions',
            'messaging', 
            'storage', 
            'analytics', 
            'remoteConfig',
            'performance',
          ].filter(feature => typeof app[feature] === 'function');
          loadEl.textContent = `Firebase SDK loaded with ${features.join(', ')}`;
        } catch (e) {
          console.error(e);
          loadEl.textContent = 'Error loading the Firebase SDK, check the console.';
        }
      });
    </script>
  </body>
</html>
</file>

<file path="public/logo_O.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="32" height="32" rx="8" fill="#4F46E5"/>
  <path d="M8 12H24M8 16H20M8 20H16" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/logo.svg">
<?xml version="1.0" encoding="utf-8" ?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="588" height="489">
	<path fill="#272F4E" d="M384.518 289.098C384.733 289.135 384.85 289.307 385.009 289.45C384.916 289.778 384.918 290.081 384.902 290.42C385.01 290.577 385.09 290.667 385.125 290.874C385.427 292.637 385.087 294.963 385.078 296.788L385.072 311.676C385.072 319.379 385.497 327.312 384.983 334.983C383.779 352.92 377.945 371.042 365.321 384.275C361.719 388.052 357.991 391.976 353.9 395.217C343.092 403.779 328.508 409.479 314.778 410.759C308.944 411.303 302.948 411.022 297.088 411.019C285.18 411.012 273.252 410.856 261.347 411.13L261.094 410.903L261.087 410.413C267.302 404.363 271.95 396.727 277.845 390.351C278.865 389.248 280.118 388.538 281.586 388.205C284.817 387.474 288.802 387.96 292.117 388.004C298.08 388.085 304.121 388.225 310.08 387.966C323.813 387.368 338.733 379.411 347.916 369.353C356.581 359.864 361 347.565 361.869 334.86C362.159 330.616 361.993 326.275 361.987 322.022C361.979 315.863 362.112 309.664 361.807 303.512C369.63 299.282 377.346 294.36 384.518 289.098Z"/>
	<path fill="#272F4E" d="M75.7158 7.0185Q76.0269 7.00549 76.3382 6.99642C90.5401 6.55936 104.898 6.99632 119.116 6.99678L206.007 6.99729L271.337 7.00648L295.403 6.98456C307.055 6.95986 317.805 6.78791 329.132 9.9876C341.935 13.6045 353.228 20.6089 362.813 29.7699C365.421 32.2624 367.633 35.1166 370.27 37.5862C365.341 39.3606 354.254 46.3878 350.616 50.0511C348.292 48.097 346.255 45.7826 343.93 43.8109C337.186 38.0922 328.73 33.5454 320.082 31.5612C309.095 29.0401 296.701 30.0605 285.463 30.0741L240.846 30.0895L132.681 30.0843C115.346 30.0818 97.9915 29.8752 80.6597 30.0537Q79.2439 30.0721 77.8308 30.1599Q76.4176 30.2476 75.0104 30.4046Q73.6033 30.5615 72.2055 30.7872Q70.8077 31.0129 69.4226 31.3069Q68.0376 31.6009 66.6686 31.9624Q65.2997 32.3239 63.9501 32.7521Q62.6004 33.1803 61.2734 33.6741Q59.9464 34.1679 58.6452 34.7262Q57.344 35.2845 56.0718 35.9059Q54.7995 36.5273 53.5592 37.2103Q52.3189 37.8933 51.1136 38.6363Q49.9082 39.3793 48.7408 40.1805Q47.5733 40.9817 46.4465 41.8391Q45.3197 42.6966 44.2363 43.6082Q43.1528 44.5199 42.1154 45.4836Q41.078 46.4472 40.089 47.4606Q38.7154 48.8704 37.4515 50.3793Q36.1875 51.8882 35.0404 53.4878Q33.8933 55.0874 32.8695 56.7685Q31.8457 58.4497 30.951 60.203Q30.0563 61.9563 29.2957 63.7718Q28.5351 65.5873 27.9129 67.4548Q27.2907 69.3223 26.8104 71.2312Q26.3301 73.1401 25.9945 75.0797C24.1776 85.7444 25.0217 97.6859 25.0241 108.534L25.0429 162.475L25.0301 278.283C25.0241 297.277 24.6809 316.33 25.0076 335.317C25.2622 350.116 32.4391 363.281 42.8863 373.372C58.7207 388.666 78.4726 389.222 99.0869 388.833C98.9997 391.631 99.0669 394.45 99.0684 397.25L99.0722 448.307C101.055 447.005 102.854 445.318 104.69 443.816L117.358 433.254C126.342 425.703 135.541 418.388 144.56 410.869C152.519 404.233 160.36 397.298 168.548 390.956C169.69 390.072 171.295 388.664 172.722 388.302C176.285 387.398 186.94 388.011 191.307 388.014C206.185 388.024 221.096 387.831 235.968 388.241C238.509 395.771 240.34 403.47 242.427 411.128C234.745 410.602 226.761 411.009 219.047 411.006C206.241 411.001 193.408 410.827 180.605 411.151C176.172 415.335 171.096 418.949 166.381 422.824L134.371 449.027L110.753 468.339C104.842 473.271 97.7068 479.723 91.3568 483.789C89.7929 484.79 87.8603 485.159 86.0206 485.179C83.2558 485.208 80.6095 484.331 78.6426 482.332C76.9316 480.593 76.5306 478.502 76.2414 476.157C75.4761 469.952 76.0256 461.262 76.0294 454.809L76.0877 411.071C71.5412 411.164 67.0691 410.299 62.6714 409.209C48.7793 405.766 36.6414 399.219 26.0636 389.585C22.6034 386.433 19.7179 382.775 16.945 379.022C5.46182 363.48 2.04583 347.63 1.23657 328.581C1.03844 323.917 1.05195 318.79 1.31853 314.135C1.46977 311.494 1.83759 308.869 1.94481 306.224C2.14904 301.187 2.0079 296.096 2.00813 291.052L2.00745 181.882L2.00301 112.279L1.98078 91.81C1.97479 84.6931 1.79667 77.8142 3.14119 70.7863C6.03283 55.6716 13.2304 42.3615 23.5651 31.0494C36.3865 17.0155 56.7931 7.85574 75.7158 7.0185Z"/>
	<path fill="#272F4E" d="M193.966 61.5628C194.503 61.4344 195.119 61.3943 195.673 61.3916Q197.432 61.3895 199.191 61.4307Q200.949 61.4719 202.706 61.5563Q204.463 61.6407 206.217 61.7683Q207.972 61.8959 209.723 62.0666Q211.473 62.2373 213.219 62.451Q214.965 62.6647 216.705 62.9213Q218.446 63.1779 220.179 63.4772Q221.912 63.7765 223.638 64.1184Q225.363 64.4602 227.08 64.8444Q228.797 65.2286 230.503 65.6548Q232.21 66.0811 233.905 66.5492Q235.601 67.0173 237.285 67.527Q238.968 68.0367 240.639 68.5876Q242.309 69.1385 243.966 69.7304Q245.622 70.3222 247.264 70.9546Q248.905 71.587 250.53 72.2596Q252.156 72.9321 253.764 73.6445Q255.372 74.3568 256.963 75.1085Q258.553 75.8602 260.125 76.6507Q261.696 77.4413 263.247 78.2703Q264.799 79.0993 266.33 79.9661Q267.86 80.833 269.369 81.7373Q270.878 82.6415 272.364 83.5826Q273.85 84.5237 275.313 85.5011Q276.775 86.4784 278.213 87.4915Q279.652 88.5045 281.064 89.5526Q282.477 90.6007 283.864 91.6832Q285.25 92.7657 286.61 93.882Q287.969 94.9983 289.301 96.1477Q290.633 97.2971 291.936 98.4788Q293.239 99.6606 294.512 100.874Q295.786 102.088 297.029 103.332C295.398 106.129 293.484 108.757 291.918 111.597C290.451 114.256 289.462 117.795 287.563 120.128C284.917 123.382 270.49 131.145 265.838 134.502C266.403 135.506 266.828 136.573 267.213 137.658C267.722 139.089 268.313 140.972 268.032 142.496C267.529 145.222 262.927 151.703 261.347 154.606C259.808 157.435 258.399 160.354 257.016 163.262C254.608 155.68 253.229 147.988 250.502 140.394C235.377 145.386 219.983 149.073 204.029 150.041L204.047 188.041C218.41 187.638 232.95 187.779 247.32 187.931C246.001 193.371 244.356 198.732 242.951 204.152C237.729 203.789 208.208 203.444 204.492 204.702C203.372 208.102 204.05 236.831 204.08 243.17C209.206 243.117 232.228 245.052 235.624 248.018C236.855 251.201 235.928 259.744 236.031 263.571C225.719 260.682 214.714 259.25 204.021 259.024C204.433 277.836 203.928 296.702 204.141 315.525C209.04 313.022 213.109 309.823 217.293 306.301C224.267 300.578 232.215 290.731 236.969 282.993C237.094 288.686 238.328 294.775 239.518 300.339C239.986 302.522 240.717 304.802 240.974 307.003C241.032 307.501 240.893 307.946 240.761 308.423C240.645 308.84 240.515 309.168 240.518 309.607C240.52 310.006 241.601 310.955 241.917 311.287C239.826 316.14 236.203 321.522 232.821 325.577C231.831 326.763 230.696 327.929 229.313 328.649C224.457 331.179 214.122 332.185 208.652 332.7C204.459 333.095 200.258 333.056 196.051 333.07C191.526 333.086 186.971 333.212 182.461 332.813C157.207 330.581 131.224 320.311 111.707 303.996C84.4108 281.176 66.0741 247.523 63.0619 211.963C62.6535 207.141 62.0904 202.194 62.1041 197.357C62.1129 194.244 62.5308 191.12 62.7613 188.017C64.923 158.917 75.36 130.49 94.437 108.117Q95.3716 107.006 96.3308 105.916Q97.29 104.826 98.2733 103.758Q99.2566 102.689 100.263 101.643Q101.27 100.597 102.3 99.5737Q103.33 98.5503 104.383 97.5502Q105.435 96.55 106.51 95.5736Q107.585 94.5972 108.681 93.6451Q109.777 92.6929 110.894 91.7654Q112.011 90.838 113.148 89.9357Q114.286 89.0334 115.443 88.1567Q116.601 87.28 117.777 86.4293Q118.954 85.5787 120.149 84.7545Q121.345 83.9304 122.558 83.1331Q123.771 82.3358 125.002 81.5658Q126.233 80.7957 127.481 80.0534Q128.729 79.3111 129.993 78.5967Q131.257 77.8824 132.536 77.1965Q133.816 76.5106 135.111 75.8534Q136.405 75.1962 137.714 74.568Q139.023 73.9399 140.346 73.3411Q141.669 72.7424 143.004 72.1733Q144.34 71.6042 145.688 71.065Q147.036 70.5258 148.396 70.0169Q149.756 69.508 151.126 69.0295Q152.497 68.5511 153.878 68.1033Q155.259 67.6556 156.65 67.2388Q158.041 66.822 159.441 66.4363Q160.84 66.0506 162.248 65.6963Q163.656 65.342 165.072 65.0192Q166.487 64.6964 167.91 64.4052Q169.332 64.1141 170.761 63.8547Q172.189 63.5954 173.623 63.368C180.449 62.2576 187.101 62.1318 193.966 61.5628ZM78.5684 205.153C77.1476 207.725 82.3434 229.55 83.3676 233.093C87.0571 245.855 95.7591 262.66 104.736 272.368C109.546 268.414 115.274 266.025 120.558 262.832C123.725 261.16 126.925 259.526 130.04 257.759C126.066 251.059 121.246 214.353 121.073 205.042C106.935 205.2 92.7035 205.311 78.5684 205.153ZM103.516 123.586C89.1416 142.477 79.4209 164.149 78.8923 188.219C86.4981 189.788 96.2074 189.005 104.077 188.988C109.718 188.973 115.42 188.801 121.054 189.02C121.879 183.103 121.775 177.289 122.397 171.39C123.641 159.573 125.79 148.205 128.418 136.63C122.345 133.885 116.253 130.874 110.401 127.686C108.077 126.42 105.863 124.741 103.516 123.586ZM152.677 204.873C147.45 204.933 142.184 205.116 136.96 205.005C138.097 216.525 139.312 227.871 141.574 239.244C142.423 243.513 143.278 248.162 145.027 252.167C149.699 249.286 160.98 247.152 166.744 246.102C170.956 245.16 175.392 244.689 179.69 244.291C181.957 244.081 185.039 244.285 187.133 243.565C188.847 240.464 187.864 210.99 187.98 204.842Q170.328 204.76 152.677 204.873ZM144.399 141.664C139.666 156.426 137.356 172.77 137.03 188.245C140.26 188.415 143.554 188.808 146.783 188.758C150.428 188.701 154.06 188.19 157.71 188.123C165.093 187.987 172.49 188.06 179.874 188.05L188.046 188.019C187.772 175.364 187.777 162.613 187.933 149.955C176.802 148.671 153.662 147.168 144.399 141.664ZM204.189 77.6068C203.663 87.9492 204.047 98.4664 204.042 108.826C204.039 116.559 203.37 125.331 204.519 132.945L204.847 132.782L204.601 133.245C206.178 134.31 219.207 131.965 221.966 131.43C227.381 130.381 232.944 129.176 238.23 127.581C240.385 126.883 242.489 126.174 244.565 125.258C236.816 109.411 226.815 94.0863 212.911 82.9311C210.685 81.1453 207.906 78.8408 205.221 77.9193C204.878 77.8017 204.539 77.7025 204.189 77.6068ZM187.378 77.7857C182.886 79.9842 178.925 83.6498 175.4 87.1506C164.068 98.4055 154.725 111.953 149.131 126.971C151.461 127.545 153.772 128.254 156.115 128.759Q165.322 131.307 174.805 132.459C179.177 133.005 183.621 133.198 187.947 134.05C187.902 128.584 188.472 79.2761 187.571 77.9705C187.52 77.8972 187.442 77.8473 187.378 77.7857ZM182.722 259.978C172.362 260.592 158.933 262.961 149.554 267.631C154.974 279.579 161.732 291.083 170.416 300.965Q172.245 303.257 174.277 305.371Q176.309 307.485 178.527 309.403Q180.745 311.321 183.13 313.027Q185.515 314.733 188.047 316.212C187.868 297.464 187.57 278.593 188.009 259.851C186.254 259.887 184.473 259.86 182.722 259.978ZM134.077 273.931C127.3 277.414 121.132 281.263 114.806 285.496C122.42 292.549 131.777 299.072 141.135 303.561C145.566 305.764 150.203 307.474 154.627 309.655C146.382 299.242 140.985 288.892 135.949 276.649C135.521 275.609 135.287 274.19 134.077 273.931ZM152.847 86.2152C142.941 89.391 121.271 102.749 114.405 110.263C116.696 112.115 119.026 113.776 121.6 115.225C125.532 117.24 129.745 119.056 133.479 121.403C137.628 113.479 140.785 105.283 145.702 97.73C146.881 95.9182 153.032 87.4452 153.063 86.4031L152.847 86.2152ZM239.935 85.9822C242.54 89.7731 245.459 93.3277 248.096 97.0924C252.732 103.712 257.334 111.616 260.406 119.093C263.728 116.571 267.779 114.852 271.311 112.607L278.194 108.15C272.733 102.741 247.06 86.4086 239.935 85.9822Z"/>
	<path fill="#272F4E" d="M525.202 5.02463C533.748 4.72459 542.364 4.99475 550.918 4.97688C562.096 4.95354 573.792 4.1709 584.811 6.24966L584.613 6.33976L585.26 6.08716L585.418 6.40337L585.305 6.66065C582.439 7.67007 580.003 9.50863 577.388 11.022C573.729 13.1385 570.036 15.186 566.402 17.3445C548.735 27.8361 535.539 37.6472 520.202 51.2239C515.36 55.5102 510.543 59.6862 506.135 64.4414C497.341 73.9296 489.517 84.3236 481.574 94.5139C475.149 96.7225 464.189 98.027 457.132 99.3626L421.771 106.397C414.475 107.857 407.096 109.086 399.866 110.832C403.687 111.216 407.217 110.607 411.007 110.261L421.483 109.405L474.309 104.766C468.919 113.869 463.333 122.877 458.443 132.266C456.556 135.889 454.702 139.581 452.992 143.292C451.664 146.174 450.494 150.382 448.486 152.781C444.47 157.581 382.122 175.684 370.002 181.18C374.259 180.975 378.451 179.512 382.613 178.629C389.363 177.198 440.719 165.408 443.113 166.197C443.069 167.317 442.697 168.34 442.336 169.392C440.001 176.198 437.206 182.865 434.792 189.649C430.706 201.13 426.18 213.948 418.644 223.65C408.715 236.432 391.418 242.981 376.167 246.452C370.777 247.678 365.263 248.599 359.787 249.357C356.95 249.749 353.903 249.863 351.127 250.498C350.033 250.749 348.98 251.304 347.974 251.791C351.371 252.243 355.015 252.013 358.443 252.025C368.479 252.062 378.182 251.792 388.143 250.448C390.828 250.086 405.712 246.692 406.809 247.155L406.774 247.673C402.883 251.578 399.698 256.217 396.074 260.373C389.613 267.781 382.075 274.631 374.195 280.491Q371.82 282.257 369.368 283.917Q366.917 285.576 364.394 287.124Q361.872 288.673 359.283 290.108Q356.694 291.543 354.044 292.861Q351.393 294.18 348.687 295.379Q345.981 296.579 343.224 297.656Q340.467 298.734 337.666 299.689Q334.864 300.643 332.022 301.472C325.529 303.383 318.818 304.928 312.224 306.466C308.4 307.359 304.448 308.042 300.764 309.42C294.365 311.815 287.643 316.132 282.108 320.184C283.044 322.187 283.434 324.554 283.959 326.698C285.86 335.43 288.78 343.978 290.739 352.734C287.168 358.607 281.845 364.018 277.456 369.289C273.413 374.142 269.546 379.138 265.524 384.009C261.339 389.079 257.014 393.995 252.886 399.116C254.533 393.762 255.358 388.053 256.615 382.587C258.523 374.298 260.902 365.853 262.115 357.437C265.344 356.236 269.039 354.988 270.633 351.627Q270.812 351.244 270.954 350.845Q271.095 350.446 271.198 350.035Q271.3 349.624 271.362 349.205Q271.424 348.786 271.445 348.364Q271.467 347.941 271.447 347.518Q271.427 347.095 271.367 346.676Q271.306 346.257 271.206 345.846Q271.105 345.435 270.965 345.035C269.61 341.288 266.913 340.707 263.715 339.267C261.275 339.935 258.797 340.698 257.047 342.648C254.835 345.114 254.96 348.087 255.068 351.169C256.101 352.712 258.373 354.623 258.876 356.33C259.631 358.897 253.028 385.533 252.249 390.739C252.02 392.269 251.981 393.836 251.962 395.381C249.735 390.744 248.549 385.642 247.117 380.719L240.194 357.524C238.847 353.003 237.734 348.218 235.927 343.864C238.517 340.349 240.682 336.48 243.065 332.818C247.194 326.476 251.521 320.162 255.292 313.604C254.434 310.651 253.379 307.799 252.66 304.798C249.889 293.236 248.727 280.87 248.085 269C247.635 260.684 248.128 252.378 248.875 244.102Q249.286 239.135 249.914 234.191Q250.542 229.247 251.385 224.335Q252.228 219.423 253.285 214.553Q254.342 209.682 255.611 204.863Q256.879 200.043 258.358 195.284Q259.836 190.524 261.52 185.834Q263.205 181.144 265.093 176.532Q266.981 171.919 269.069 167.394C273.412 157.759 278.778 147.268 285.874 139.362C286.862 150.484 291.122 161.253 295.774 171.287C296.545 172.951 297.441 175.678 298.75 176.951L298.892 176.397L298.594 176.867L298.445 176.695C298.613 176.53 298.865 176.419 298.948 176.198C299.093 175.813 298.09 172.007 297.948 171.309C294.358 153.679 295.05 134.48 303.268 118.201C316.518 91.9574 339.855 70.2436 364.497 54.7596C368.455 52.2725 373.757 48.3256 378.157 46.9706C378.662 46.8151 378.588 46.7612 379.071 47.0295C379.191 49.0956 377.05 55.1629 376.405 57.6774C374.851 63.7271 372.001 75.7998 372.006 81.7307L372.011 82.1658C374.068 78.4682 375.521 74.2019 377.17 70.2914C380.715 61.8836 385.246 53.8897 391.345 47.0529C394.554 43.4561 398.176 40.0295 402.135 37.2746C407.72 33.389 413.913 30.5369 420.108 27.79C444.59 16.935 471.925 10.5635 498.473 7.40397C504.868 6.64292 511.185 6.28518 517.589 5.78461C520.136 5.58546 522.638 5.16527 525.202 5.02463Z"/>
	<path fill="#FEFEFE" d="M488.855 29.9519L489.06 30.1181C487.329 31.6265 479.816 34.4027 477.223 35.5993Q471.355 38.3342 465.604 41.3053Q446.667 50.8478 429.036 62.6314Q422.26 67.208 415.719 72.1139Q409.177 77.0197 402.886 82.2427Q396.594 87.4657 390.569 92.9931Q384.543 98.5206 378.798 104.339C328.393 156.286 289.979 233.324 272.221 303.207C269.599 313.524 267.981 323.908 265.975 334.34L265.626 334.085C265.154 329.458 266.592 318.658 267.183 313.658Q268.02 306.493 269.158 299.369Q270.297 292.246 271.736 285.177Q273.174 278.108 274.91 271.106Q276.646 264.105 278.677 257.183Q280.707 250.26 283.028 243.43Q285.349 236.6 287.957 229.874Q290.565 223.148 293.454 216.538Q296.344 209.929 299.51 203.447C332.695 136.653 375.746 85.8466 442.23 50.5474C457.201 42.5993 472.777 35.3557 488.855 29.9519Z"/>
</svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/actions/dictation.ts">
'use server'
import { z } from 'zod'
import type { DictationGame } from '@/lib/types'
import { auth } from "@/lib/auth"
import { getFirestore } from 'firebase-admin/firestore'
import { initAdminApp } from '@/lib/firebase-admin'
const CreateDictationSchema = z.object({
  id: z.string().optional(),
  title: z.string(),
  description: z.string().optional(),
  sourceLanguage: z.string(),
  targetLanguage: z.string(),
  wordPairs: z.array(z.object({
    first: z.string(),
    second: z.string(),
    sentence: z.string().optional(),
  })),
  quizParameters: z.object({
    globalTimeLimit: z.number(),
    globalLivesLimit: z.number(),
    activityTimeLimit: z.number(),
    quizModeEnabled: z.boolean(),
  }),
})
export type CreateDictationInput = z.infer<typeof CreateDictationSchema>
export async function createDictation(data: CreateDictationInput): Promise<{ error?: string, game?: DictationGame }> {
  try {
    const session = await auth()
    if (!session?.user?.email || !session?.user?.id) {
      return { error: 'Not authenticated' }
    }
    // Validate input
    const validatedData = CreateDictationSchema.parse(data)
    return {
      game: {
        ...validatedData,
        id: 'temp-id',
        userId: session.user.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      }
    }
  } catch (error) {
    console.error('Error creating dictation:', error)
    if (error instanceof z.ZodError) {
      return { error: error.errors[0].message }
    }
    return { error: 'Failed to create dictation' }
  }
}
export interface Game {
  id: string
  title: string
  description?: string
  sourceLanguage: string
  targetLanguage: string
  wordPairs: Array<{
    first: string
    second: string
    sentence?: string
  }>
  createdAt: {
    _seconds: number
    _nanoseconds: number
    toDate?: () => Date
  }
  isPublic?: boolean
  playCount?: number
}
export async function getGames(): Promise<Game[]> {
  const session = await auth()
  if (!session?.user?.id) {
    return []
  }
  const db = getFirestore(initAdminApp())
  const gamesSnapshot = await db
    .collection('dictation_games')
    .doc(session.user.id)
    .collection('games')
    .get()
  return gamesSnapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  })) as Game[]
}
export async function deleteGame(id: string): Promise<boolean> {
  try {
    // Get the current user's session
    const session = await auth()
    if (!session?.user) return false
    // Initialize Firestore
    initAdminApp()
    const db = getFirestore()
    // Get the game document
    const gameDoc = await db.collection('dictation_games').doc(id).get()
    if (!gameDoc.exists) return false
    const gameData = gameDoc.data()
    if (!gameData) return false
    // Check if the user owns the game
    if (gameData.userId !== session.user.id) return false
    // Delete the game
    await db.collection('dictation_games').doc(id).delete()
    return true
  } catch (error) {
    console.error('Error deleting game:', error)
    return false
  }
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import { handlers } from "@/lib/auth"
export const { GET, POST } = handlers
</file>

<file path="src/app/api/dictation/create/route.ts">
import { NextResponse } from 'next/server'
import { getFirestore } from 'firebase-admin/firestore'
import { auth } from '@/lib/auth'
import { initAdminApp } from '@/lib/firebase-admin'
import { z } from 'zod'
import { getTTSUrls } from '@/lib/server/tts'
const createDictationSchema = z.object({
  title: z.string(),
  description: z.string().optional(),
  sourceLanguage: z.string(),
  targetLanguage: z.string(),
  wordPairs: z.array(z.object({
    first: z.string(),
    second: z.string(),
    sentence: z.string().optional()
  })).min(1),
  quizParameters: z.object({
    globalTimeLimit: z.number(),
    globalLivesLimit: z.number(),
    activityTimeLimit: z.number(),
    quizModeEnabled: z.boolean()
  }),
  isPublic: z.boolean().default(true),
  playCount: z.number().default(0)
})
export async function POST(request: Request) {
  try {
    // Get the current user
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    // Parse and validate the request body
    const body = await request.json()
    const validatedData = createDictationSchema.parse(body)
    // Get all unique words for source and target languages
    const sourceWords = validatedData.wordPairs.map(pair => pair.first)
    const targetWords = validatedData.wordPairs.map(pair => pair.second)
    // Generate TTS for all words in parallel
    const [sourceAudioUrls, targetAudioUrls] = await Promise.all([
      getTTSUrls(sourceWords, validatedData.sourceLanguage),
      getTTSUrls(targetWords, validatedData.targetLanguage)
    ])
    // Add audio URLs to word pairs
    const wordPairsWithAudio = validatedData.wordPairs.map(pair => ({
      ...pair,
      firstAudioUrl: sourceAudioUrls[pair.first],
      secondAudioUrl: targetAudioUrls[pair.second]
    }))
    // Initialize Firestore
    const db = getFirestore(initAdminApp())
    // Create the game document with audio URLs
    const timestamp = new Date()
    const gameData = {
      ...validatedData,
      wordPairs: wordPairsWithAudio,
      userId: session.user.id,
      createdAt: timestamp,
      updatedAt: timestamp,
    }
    // Create a new document with auto-generated ID
    const docRef = db.collection('dictation_games').doc(session.user.id)
    const userRef = docRef.collection('games').doc()
    await userRef.set(gameData)
    return NextResponse.json({ 
      success: true, 
      dictationId: userRef.id 
    })
  } catch (error) {
    console.error('Error creating dictation:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid request data', details: error.errors }, { status: 400 })
    }
    // Add more specific error handling
    if (error instanceof Error && 'code' in error) {
      if (error.code === 'not-found') {
        return NextResponse.json({ error: 'Failed to create document in Firestore. Collection might not exist.' }, { status: 500 })
      }
    }
    return NextResponse.json({ error: 'Failed to create dictation' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/dictation/drafts/route.ts">
import { NextResponse } from 'next/server'
import { getFirestore } from 'firebase-admin/firestore'
import { auth } from '@/lib/auth'
import { initAdminApp } from '@/lib/firebase-admin'
export async function GET() {
  try {
    // Get the current user
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    // Initialize Firestore
    const db = getFirestore(initAdminApp())
    // Get user's drafts (private dictations)
    const userRef = db.collection('dictation_games').doc(session.user.id)
    const draftsSnapshot = await userRef.collection('games')
      .where('isPublic', '==', false)
      .orderBy('updatedAt', 'desc')
      .get()
    const drafts = draftsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    }))
    return NextResponse.json({ drafts })
  } catch (error) {
    console.error('Error fetching drafts:', error)
    return NextResponse.json({ error: 'Failed to fetch drafts' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/dictation/edit/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { getFirestore } from 'firebase-admin/firestore'
import { initAdminApp } from '@/lib/firebase-admin'
import { auth } from '@/lib/auth'
import { DictationGame } from '@/lib/types'
import { getTTSUrls } from '@/lib/server/tts'
// Initialize Firestore
const db = getFirestore(initAdminApp())
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: dictationId } = await params
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    // Use the correct nested collection structure
    const docRef = db.collection('dictation_games')
      .doc(session.user.id)
      .collection('games')
      .doc(dictationId)
    const doc = await docRef.get()
    if (!doc.exists) {
      return NextResponse.json({ error: 'Dictation not found' }, { status: 404 })
    }
    const data = doc.data() as DictationGame
    return NextResponse.json(data)
  } catch (error) {
    console.error('Error retrieving dictation:', error)
    return NextResponse.json(
      { error: 'Failed to retrieve dictation' },
      { status: 500 }
    )
  }
}
export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: dictationId } = await params
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    const body = await req.json()
    const docRef = db.collection('dictation_games')
      .doc(session.user.id)
      .collection('games')
      .doc(dictationId)
    const doc = await docRef.get()
    if (!doc.exists) {
      return NextResponse.json({ error: 'Dictation not found' }, { status: 404 })
    }
    const currentData = doc.data() as DictationGame
    // If word pairs are being updated, generate new TTS URLs
    if (body.wordPairs) {
      // Get all unique words for source and target languages
      const sourceWords = body.wordPairs.map((pair: { first: string }) => pair.first)
      const targetWords = body.wordPairs.map((pair: { second: string }) => pair.second)
      // Generate TTS for all words in parallel
      const [sourceAudioUrls, targetAudioUrls] = await Promise.all([
        getTTSUrls(sourceWords, body.sourceLanguage || currentData.sourceLanguage),
        getTTSUrls(targetWords, body.targetLanguage || currentData.targetLanguage)
      ])
      // Add audio URLs to word pairs
      body.wordPairs = body.wordPairs.map((pair: { first: string; second: string }) => ({
        ...pair,
        firstAudioUrl: sourceAudioUrls[pair.first],
        secondAudioUrl: targetAudioUrls[pair.second]
      }))
    }
    const updatedData: Partial<DictationGame> = {
      ...body,
      updatedAt: new Date(),
    }
    await docRef.update(updatedData)
    return NextResponse.json({ message: 'Dictation updated successfully' })
  } catch (error) {
    console.error('Error updating dictation:', error)
    return NextResponse.json(
      { error: 'Failed to update dictation' },
      { status: 500 }
    )
  }
}
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: dictationId } = await params
    // Get the current user
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    // Initialize Firestore
    const db = getFirestore(initAdminApp())
    // Get reference to the game document
    const userRef = db.collection('dictation_games').doc(session.user.id)
    const gameRef = userRef.collection('games').doc(dictationId)
    // Check if the game exists and belongs to the user
    const game = await gameRef.get()
    if (!game.exists) {
      return NextResponse.json({ error: 'Game not found' }, { status: 404 })
    }
    // Delete the game
    await gameRef.delete()
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting game:', error)
    return NextResponse.json({ error: 'Failed to delete game' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/dictation/generate-content/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import OpenAI from 'openai'
import { z } from 'zod'
import { zodResponseFormat } from 'openai/helpers/zod'
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
const WordPairsList = z.object({
  title: z.string(),
  description: z.string().optional(),
    wordPairs: z.array(
        z.object({
        first: z.string(),
        second: z.string(),
        sentence: z.string(),
        imagePrompt: z.string(),
        }),
    ),
})
const RequestSchema = z.object({
  sourceLanguage: z.string(),
  targetLanguage: z.string(),
  title: z.string(),
  description: z.string(),
  wordPairs: z.array(z.object({
    first: z.string(),
    second: z.string(),
    sentence: z.string(),
  })),
})
export async function POST(req: NextRequest) {
  try {
    const body = await req.json()
    console.log('body', body)
    const { sourceLanguage='Hebrew', targetLanguage='English', wordPairs=[], title='NO TITLE', description='NO DESCRIPTION' } = RequestSchema.parse(body)
    const prompt = `Given these word pairs between ${sourceLanguage} and ${targetLanguage}, please:
        1. If a word is missing its translation, provide it
        2. For each pair, generate a natural, contextual example sentence in ${targetLanguage} using the ${targetLanguage} word
        3. For each pair, generate an English image prompt that would help visualize the word's meaning
        4. If required, generate a title and description for the content in ${sourceLanguage} - the title and description should be in natural language, SEO friendly, cool, and related to the topic of the words.
        Word pairs:
        ${wordPairs.map(pair => `${pair.first} - ${pair.second}`).join('\n')}
        title: ${title}
        description: ${description}
        Return a JSON object with the complete word pairs, including translations, sentences, and image prompts.
    `
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      response_format: zodResponseFormat(WordPairsList, 'word_pairs'),
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 3500,
    })
    const content = response.choices[0].message.content
    console.log('content', content)
    if (!content) {
      throw new Error('No content in the response')
    }
    const parsedContent = JSON.parse(content)
    return NextResponse.json(parsedContent)
  } catch (error) {
    console.error('Error generating content:', error)
    return NextResponse.json(
      { error: 'Failed to generate content' },
      { status: 500 },
    )
  }
}
</file>

<file path="src/app/api/dictation/latest/route.ts">
import { initAdminApp } from '@/lib/firebase-admin'
import { getFirestore } from 'firebase-admin/firestore'
import { NextResponse } from 'next/server'
import type { FirebaseGame } from '@/lib/types'
import type { Game } from '@/app/actions/dictation'
export async function GET() {
  try {
    initAdminApp()
    const db = getFirestore()
    // Use collectionGroup to query across all user's games subcollections
    const gamesQuery = db.collectionGroup('games')
    const snapshot = await gamesQuery
      .where('isPublic', '==', true)
      .orderBy('createdAt', 'desc')
      .limit(5)
      .get()
    const games = snapshot.docs.map(doc => {
      const data = doc.data() as FirebaseGame
      return {
        ...data,
        id: doc.id,
        createdAt: {
          _seconds: data.createdAt.seconds,
          _nanoseconds: data.createdAt.nanoseconds,
          toDate: () => data.createdAt.toDate()
        }
      }
    }) as Game[]
    return NextResponse.json({ games })
  } catch (error) {
    console.error('Error fetching latest games:', error)
    return NextResponse.json(
      { error: 'Failed to fetch latest games' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/dictation/list/route.ts">
import { NextResponse } from 'next/server'
import { getFirestore } from 'firebase-admin/firestore'
import { auth } from '@/lib/auth'
import { initAdminApp } from '@/lib/firebase-admin'
export async function GET() {
  try {
    // Get the current user
    const session = await auth()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }
    // Initialize Firestore
    const db = getFirestore(initAdminApp())
    // Get user's games
    const userRef = db.collection('dictation_games').doc(session.user.id)
    const gamesSnapshot = await userRef.collection('games')
      .orderBy('createdAt', 'desc')
      .get()
    const games = gamesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    }))
    return NextResponse.json({ games })
  } catch (error) {
    console.error('Error fetching games:', error)
    return NextResponse.json({ error: 'Failed to fetch games' }, { status: 500 })
  }
}
</file>

<file path="src/app/api/dictation/play/[id]/route.ts">
export const revalidate = 0
export const dynamic = 'force-dynamic'
import { NextRequest, NextResponse } from 'next/server'
import { getFirestore } from 'firebase-admin/firestore'
import { initAdminApp } from '@/lib/firebase-admin'
import { auth } from '@/lib/auth'
import { getTTSUrls } from '@/lib/server/tts'
// Define the word pair interface based on the application's structure
interface WordPair {
  first: string
  second: string
  sentence?: string
  firstAudioUrl?: string
  secondAudioUrl?: string
}
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: dictationId } = await params
    const db = getFirestore(initAdminApp())
    // Get all games and find the one with matching ID
    const gamesQuery = await db.collectionGroup('games').get()
    const gameDoc = gamesQuery.docs.find(doc => doc.id === dictationId)
    if (!gameDoc) {
      return NextResponse.json(
        { error: 'Game not found' },
        { status: 404 }
      )
    }
    const gameData = gameDoc.data()
    // Check auth for private games
    if (!gameData.isPublic) {
      // If game is private, verify user session
      const session = await auth()
      const userId = session?.user?.id
      // If no session and game is private, deny access
      if (!userId) {
        return NextResponse.json(
          { error: 'Game not accessible' },
          { status: 403 }
        )
      }
      // Check if user owns the game
      if (gameDoc.ref.parent.parent?.id !== userId) {
        return NextResponse.json(
          { error: 'Game not accessible' },
          { status: 403 }
        )
      }
    }
    // Refresh the TTS URLs for all word pairs in the game
    if (gameData.wordPairs && gameData.wordPairs.length > 0) {
      // Extract all unique words from the word pairs
      const sourceWords = gameData.wordPairs.map((pair: WordPair) => pair.first)
      const targetWords = gameData.wordPairs.map((pair: WordPair) => pair.second)
      // Generate fresh TTS URLs for all words in parallel
      const [sourceResult, targetResult] = await Promise.allSettled([
        getTTSUrls(sourceWords, gameData.sourceLanguage),
        getTTSUrls(targetWords, gameData.targetLanguage)
      ])
      //console.log('sourceResult', {sourceWords, gameData.sourceLanguage, sourceResult})
      console.log('targetResult', {targetWords, targetLanguage:gameData.targetLanguage, targetResult})
      // Initialize empty URL objects in case of failures
      const sourceAudioUrls: Record<string, string> = {}
      const targetAudioUrls: Record<string, string> = {}
      // Extract results if promises were fulfilled
      if (sourceResult.status === 'fulfilled') {
       Object.assign(sourceAudioUrls, sourceResult.value)
      } else {
       console.error('Error generating source language TTS:', sourceResult.reason)
      }
      if (targetResult.status === 'fulfilled') {
        Object.assign(targetAudioUrls, targetResult.value)
      } else {
        console.error('Error generating target language TTS:', targetResult.reason)
      }
      // Update word pairs with fresh URLs when available
      gameData.wordPairs = gameData.wordPairs.map((pair: WordPair) => ({
        ...pair,
        firstAudioUrl: sourceAudioUrls[pair.first] || pair.firstAudioUrl,
        secondAudioUrl: targetAudioUrls[pair.second] || pair.secondAudioUrl
      }))
    }
    // Return the game data with refreshed URLs
    return NextResponse.json({
      id: gameDoc.id,
      ...gameData
    })
  } catch (error) {
    console.error('Error retrieving dictation:', error)
    return NextResponse.json(
      { error: 'Failed to retrieve dictation' },
      { status: 500 }
    )
  }
}
export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: dictationId } = await params
    const db = getFirestore(initAdminApp())
    // Get all games and find the one with matching ID
    const gamesQuery = await db.collectionGroup('games').get()
    const gameDoc = gamesQuery.docs.find(doc => doc.id === dictationId)
    if (!gameDoc) {
      return NextResponse.json(
        { error: 'Game not found' },
        { status: 404 }
      )
    }
    // Increment the play count
    await gameDoc.ref.update({
      playCount: (gameDoc.data().playCount || 0) + 1
    })
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error updating play count:', error)
    return NextResponse.json(
      { error: 'Failed to update play count' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/dictation/tts/route.ts">
export const dynamic = 'force-dynamic'
import { NextRequest, NextResponse } from 'next/server'
import { ElevenLabsClient } from 'elevenlabs'
import { getStorage } from 'firebase-admin/storage'
import { initAdminApp } from '@/lib/firebase-admin'
import crypto from 'crypto'
import { Readable } from 'stream'
const storage = getStorage(initAdminApp())
const bucket = storage.bucket(process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET)
const client = new ElevenLabsClient({ apiKey: process.env.ELEVENLABS_API_KEY })
// Hash function to create consistent filenames
function hashWord(word: string): string {
  return crypto.createHash('md5').update(word.toLowerCase()).digest('hex')
}
// Helper function to convert Node.js Readable to Buffer
async function streamToBuffer(stream: Readable): Promise<Buffer> {
  const chunks: Buffer[] = []
  for await (const chunk of stream) {
    chunks.push(Buffer.from(chunk))
  }
  return Buffer.concat(chunks)
}
// Function to get or create TTS file
async function getOrCreateTTS(word: string): Promise<string> {
  const hashedWord = hashWord(word)
  const filePath = `tts/en/${hashedWord}.mp3`
  const file = bucket.file(filePath)
  try {
    // Check if file exists
    const [exists] = await file.exists()
    if (exists) {
      // Get signed URL that expires in 24 hours instead of 1 hour
      const [url] = await file.getSignedUrl({
        action: 'read',
        expires: Date.now() + 86400000 // 24 hours (was 3600000 for 1 hour)
      })
      return url
    }
    // File doesn't exist, generate new TTS
    try {
      const ttsResponse = await client.textToSpeech.convert('JBFqnCBsd6RMkjVDRZzb', {
        output_format: 'mp3_44100_128',
        language_code: 'en',
        text: word,
        model_id: 'eleven_turbo_v2_5'
      })
      // Convert stream to Buffer
      const audioBuffer = await streamToBuffer(ttsResponse)
      // Upload to Firebase Storage
      await file.save(audioBuffer, {
        contentType: 'audio/mp3',
        metadata: {
          language: 'en',
          word
        }
      })
      console.log('file saved')
      // Get signed URL with extended expiration time
      const [url] = await file.getSignedUrl({
        action: 'read',
        expires: Date.now() + 86400000 // 24 hours (was 3600000 for 1 hour)
      })
      return url
    } catch(error) {
      console.error('Error generating TTS with ElevenLabs', error)
      throw error
    }
  } catch (error) {
    console.error('Error getting existing TTS', error)
    throw error
  }
}
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { words, language } = body
    if (!words) {
      console.error('Missing required parameters')
      return NextResponse.json(
        { error: 'Missing required parameters' },
        { status: 400 }
      )
    }
    // Only process if language is English
    if (language && language !== 'en' && language !== 'English') {
      return NextResponse.json({ 
        success: true, 
        results: Array.isArray(words) ? words.map(word => ({ word, url: null })) : [{ word: words, url: null }]
      })
    }
    // Handle single word or array of words
    const wordsArray = Array.isArray(words) ? words : [words]
    // Process all words and handle failures gracefully
    const settledResults = await Promise.allSettled(
      wordsArray.map(word => getOrCreateTTS(word))
    )
    // Map results, providing null URLs for failed generations
    const results = settledResults.map((result, index) => ({
      word: wordsArray[index],
      url: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason?.message : undefined
    }))
    return NextResponse.json({ 
      success: true, 
      results,
      // Include a summary of failures if any occurred
      failureCount: results.filter(r => !r.url).length
    })
  } catch (error) {
    console.error('TTS API Error:', error)
    return NextResponse.json(
      { error: 'Failed to process TTS request' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/api/dictation/upload/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { extractWordPairsFromImage, extractWordPairsFromText, type WordPairsList } from '@/lib/openai'
const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
const TIMEOUT_DURATION = 55000 // 55 seconds (slightly less than Vercel's 60s limit)
export async function POST(req: NextRequest) {
  try {
    // Add timeout wrapper
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error('Request timeout - Processing is taking longer than expected'))
      }, TIMEOUT_DURATION)
    })
    const formData = await req.formData()
    const file = formData.get('file') as File | null
    const firstLanguage = formData.get('firstLanguage') as string
    const secondLanguage = formData.get('secondLanguage') as string
    if (!file) {
      return NextResponse.json(
        { error: 'No file uploaded' },
        { status: 400 }
      )
    }
    if (!firstLanguage || !secondLanguage) {
      return NextResponse.json(
        { error: 'Languages are required' },
        { status: 400 }
      )
    }
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: 'File size must be less than 10MB' },
        { status: 400 }
      )
    }
    let result: WordPairsList
    // Race between the actual processing and timeout
    if (file.type.startsWith('image/')) {
      const arrayBuffer = await file.arrayBuffer()
      const base64 = Buffer.from(arrayBuffer).toString('base64')
      result = await Promise.race([
        extractWordPairsFromImage(base64, firstLanguage, secondLanguage),
        timeoutPromise
      ]) as WordPairsList
    } else if (file.type === 'text/plain' || file.type === 'text/csv' || file.name.endsWith('.csv')) {
      const text = await file.text()
      result = await Promise.race([
        extractWordPairsFromText(text, firstLanguage, secondLanguage),
        timeoutPromise
      ]) as WordPairsList
    } else {
      return NextResponse.json(
        { error: 'Unsupported file type. Please upload a text, CSV, or image file.' },
        { status: 400 }
      )
    }
    if (!result.wordPairs.length) {
      return NextResponse.json(
        { error: 'No word pairs could be extracted from the file' },
        { status: 400 }
      )
    }
    return NextResponse.json({
      ...result,
      message: `Successfully extracted ${result.wordPairs.length} word pairs`
    })
  } catch (error) {
    console.error('Error processing file:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process file' },
      { status: 500 }
    )
  }
}
</file>

<file path="src/app/auth/error/page.tsx">
import { XCircleIcon } from "@heroicons/react/20/solid"
import Link from "next/link"
export default async function AuthError({
  searchParams,
}: {
  searchParams: Promise<{ error?: string }>
}) {
  const { error = "An error occurred during authentication" } = await searchParams
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <div className="rounded-md bg-red-50 p-4">
          <div className="flex">
            <div className="flex-shrink-0">
              <XCircleIcon
                className="h-5 w-5 text-red-400"
                aria-hidden="true"
              />
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                Authentication Error
              </h3>
              <div className="mt-2 text-sm text-red-700">
                <p>{error}</p>
              </div>
            </div>
          </div>
        </div>
        <div className="mt-4 text-center">
          <Link
            href="/auth/signin"
            className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
          >
            Return to sign in
          </Link>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/reset-password/page.tsx">
import { getAuth, verifyPasswordResetCode } from 'firebase/auth'
import { initFirebaseApp } from '@/lib/firebase'
import ResetPasswordForm from './ResetPasswordForm'
interface PageProps {
  searchParams: Promise<{ oobCode?: string | string[] }>
}
export default async function ResetPasswordPage({ searchParams }: PageProps) {
  const { oobCode: _oobCode } = await searchParams
  const oobCode = typeof _oobCode === 'string' ? _oobCode : undefined
  let error: string | null = null
  let email: string | null = null
  if (!oobCode) {
    error = 'Invalid password reset link'
  } else {
    try {
      const auth = getAuth(initFirebaseApp())
      email = await verifyPasswordResetCode(auth, oobCode)
    } catch (err: any) {
      console.error('Error verifying reset code:', err)
      error = 'This password reset link is invalid or has expired'
    }
  }
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight">
          Reset your password
        </h2>
        {email && (
          <p className="mt-2 text-center text-sm text-gray-600">
            for {email}
          </p>
        )}
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white px-4 py-8 shadow sm:rounded-lg sm:px-10">
          {error ? (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                </div>
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">
                    {error}
                  </h3>
                </div>
              </div>
            </div>
          ) : (
            <ResetPasswordForm oobCode={oobCode} />
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/reset-password/ResetPasswordForm.tsx">
'use client'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { getAuth, confirmPasswordReset } from 'firebase/auth'
import { initFirebaseApp } from '@/lib/firebase'
interface ResetPasswordFormProps {
  oobCode: string | undefined
}
export default function ResetPasswordForm({ oobCode }: ResetPasswordFormProps) {
  const router = useRouter()
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)
  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setError(null)
    if (!oobCode) {
      setError('Invalid reset code')
      return
    }
    const formData = new FormData(event.currentTarget)
    const password = formData.get('password') as string
    const confirmPassword = formData.get('confirmPassword') as string
    if (password !== confirmPassword) {
      setError('Passwords do not match')
      return
    }
    if (password.length < 6) {
      setError('Password must be at least 6 characters')
      return
    }
    try {
      const auth = getAuth(initFirebaseApp())
      await confirmPasswordReset(auth, oobCode, password)
      setSuccess(true)
      // Redirect to sign in page after 3 seconds
      setTimeout(() => {
        router.push('/auth/signin')
      }, 3000)
    } catch (error: any) {
      console.error('Error resetting password:', error)
      setError('Failed to reset password. Please try again')
    }
  }
  if (success) {
    return (
      <div className="rounded-md bg-green-50 p-4">
        <div className="flex">
          <div className="flex-shrink-0">
            <svg className="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
            </svg>
          </div>
          <div className="ml-3">
            <h3 className="text-sm font-medium text-green-800">
              Password reset successful
            </h3>
            <div className="mt-2 text-sm text-green-700">
              <p>
                Your password has been reset. Redirecting to sign in...
              </p>
            </div>
          </div>
        </div>
      </div>
    )
  }
  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="rounded-md bg-red-50 p-4 mb-6">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                {error}
              </h3>
            </div>
          </div>
        </div>
      )}
      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700"
        >
          New password
        </label>
        <div className="mt-1">
          <input
            id="password"
            name="password"
            type="password"
            required
            className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
          />
        </div>
      </div>
      <div>
        <label
          htmlFor="confirmPassword"
          className="block text-sm font-medium text-gray-700"
        >
          Confirm new password
        </label>
        <div className="mt-1">
          <input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            required
            className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
          />
        </div>
      </div>
      <div>
        <button
          type="submit"
          className="flex w-full justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
        >
          Reset password
        </button>
      </div>
    </form>
  )
}
</file>

<file path="src/app/auth/signin/page.tsx">
import { auth } from "@/lib/auth"
import { redirect } from "next/navigation"
import SignInForm from "./SignInForm"
export default async function SignInPage({
  searchParams,
}: {
  searchParams: Promise<{ from?: string | string[] }>
}) {
  const session = await auth()
  const { from: _from } = await searchParams
  const from = typeof _from === 'string' ? _from : "/"
  if (session) {
    redirect(from)
  }
  return <SignInForm from={from} />
}
</file>

<file path="src/app/auth/signin/SignInForm.tsx">
"use client"
import Link from "next/link"
import { useFormState, useFormStatus } from "react-dom"
import { useRouter } from "next/navigation"
import { handleCredentialsSignIn, handleGoogleSignIn } from "../actions"
function SubmitButton() {
  const { pending } = useFormStatus()
  return (
    <button
      type="submit"
      disabled={pending}
      className="flex w-full justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {pending ? (
        <div className="flex items-center">
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Signing in...
        </div>
      ) : (
        'Sign in'
      )}
    </button>
  )
}
function GoogleSignInButton() {
  const { pending } = useFormStatus()
  return (
    <button
      type="submit"
      disabled={pending}
      className="flex w-full items-center justify-center gap-3 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {pending ? (
        <div className="flex items-center">
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Connecting...
        </div>
      ) : (
        <>
          <svg className="h-5 w-5" aria-hidden="true" viewBox="0 0 24 24">
            <path
              d="M12.0003 4.75C13.7703 4.75 15.3553 5.36002 16.6053 6.54998L20.0303 3.125C17.9502 1.19 15.2353 0 12.0003 0C7.31028 0 3.25527 2.69 1.28027 6.60998L5.27028 9.70498C6.21525 6.86002 8.87028 4.75 12.0003 4.75Z"
              fill="#EA4335"
            />
            <path
              d="M23.49 12.275C23.49 11.49 23.415 10.73 23.3 10H12V14.51H18.47C18.18 15.99 17.34 17.25 16.08 18.1L19.945 21.1C22.2 19.01 23.49 15.92 23.49 12.275Z"
              fill="#4285F4"
            />
            <path
              d="M5.26498 14.2949C5.02498 13.5699 4.88501 12.7999 4.88501 11.9999C4.88501 11.1999 5.01998 10.4299 5.27028 9.7049L1.28027 6.60986C0.47027 8.22986 0 10.0599 0 11.9999C0 13.9399 0.47027 15.7699 1.28027 17.3899L5.26498 14.2949Z"
              fill="#FBBC05"
            />
            <path
              d="M12.0004 24C15.2354 24 17.9504 22.935 19.9454 21.095L16.0804 18.095C15.0054 18.82 13.6204 19.245 12.0004 19.245C8.87043 19.245 6.21542 17.135 5.26544 14.29L1.27545 17.385C3.25045 21.31 7.31046 24 12.0004 24Z"
              fill="#34A853"
            />
          </svg>
          <span>Google</span>
        </>
      )}
    </button>
  )
}
export default function SignInForm({ from }: { from: string }) {
  const router = useRouter()
  const [state, formAction] = useFormState(
    async (prevState: any, formData: FormData) => {
      const email = formData.get("email") as string
      const password = formData.get("password") as string
      const result = await handleCredentialsSignIn(email, password, from)
      if (result.success) {
        router.push(result.redirectTo || '/')
        return null
      }
      return result
    },
    null
  )
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight">
          Sign in to your account
        </h2>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white px-4 py-8 shadow sm:rounded-lg sm:px-10">
          {state?.error && (
            <div className="rounded-md bg-red-50 p-4 mb-6">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                </div>
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">
                    {state.error}
                  </h3>
                  {process.env.NODE_ENV === 'development' && state.errorCode && (
                    <p className="mt-1 text-xs text-red-600">
                      Error code: {state.errorCode}
                    </p>
                  )}
                </div>
              </div>
            </div>
          )}
          <form action={formAction} className="space-y-6">
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                Email address
              </label>
              <div className="mt-1">
                <input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  required
                  className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
                />
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between">
                <label
                  htmlFor="password"
                  className="block text-sm font-medium text-gray-700"
                >
                  Password
                </label>
                <div className="text-sm">
                  <Link
                    href="/auth/reset-password"
                    className="font-medium text-indigo-600 hover:text-indigo-500"
                  >
                    Forgot password?
                  </Link>
                </div>
              </div>
              <div className="mt-1">
                <input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete="current-password"
                  required
                  className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
                />
              </div>
            </div>
            <div>
              <SubmitButton />
            </div>
          </form>
          <div className="mt-6">
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-gray-300" />
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="bg-white px-2 text-gray-500">
                  Or continue with
                </span>
              </div>
            </div>
            <div className="mt-6">
              <form
                action={async () => {
                  await handleGoogleSignIn(from)
                }}
              >
                <GoogleSignInButton />
              </form>
            </div>
          </div>
        </div>
        <div className="mt-6 text-center">
          <div className="text-sm">
            {`Don't have an account?`}
            <Link
              href="/auth/signup"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign up
            </Link>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/signup/page.tsx">
import { auth } from "@/lib/auth"
import { redirect } from "next/navigation"
import SignUpForm from "./SignUpForm"
export default async function SignUpPage({
  searchParams,
}: {
  searchParams: Promise<{ from?: string | string[] }>
}) {
  const session = await auth()
  const { from: _from } = await searchParams
  const from = typeof _from === 'string' ? _from : "/"
  if (session) {
    redirect(from)
  }
  return <SignUpForm from={from} />
}
</file>

<file path="src/app/auth/signup/SignUpForm.tsx">
"use client"
import Link from "next/link"
import { useFormStatus } from "react-dom"
import { handleSignUp } from "../actions"
import { redirect } from "next/navigation"
function SubmitButton() {
  const { pending } = useFormStatus()
  return (
    <button
      type="submit"
      disabled={pending}
      className="flex w-full justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {pending ? (
        <div className="flex items-center">
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Creating account...
        </div>
      ) : (
        'Sign up'
      )}
    </button>
  )
}
interface SignUpFormProps {
  from: string
}
export default function SignUpForm({ from }: SignUpFormProps) {
  async function createUser(formData: FormData) {
    const email = formData.get("email") as string
    const password = formData.get("password") as string
    const result = await handleSignUp(email, password)
    if (result.success) {
      redirect(from)
    } else {
      redirect(`/auth/error?error=${encodeURIComponent(result.error || 'Unknown error')}`)
    }
  }
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight">
          Create your account
        </h2>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white px-4 py-8 shadow sm:rounded-lg sm:px-10">
          <form action={createUser} className="space-y-6">
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700"
              >
                Email address
              </label>
              <div className="mt-1">
                <input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  required
                  className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
                />
              </div>
            </div>
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                Password
              </label>
              <div className="mt-1">
                <input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete="new-password"
                  required
                  className="block w-full appearance-none rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
                />
              </div>
            </div>
            <div>
              <SubmitButton />
            </div>
          </form>
          <div className="mt-6">
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-gray-300" />
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="bg-white px-2 text-gray-500">
                  Already have an account?
                </span>
              </div>
            </div>
            <div className="mt-6 text-center">
              <Link
                href="/auth/signin"
                className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
              >
                Sign in instead
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/update-email/page.tsx">
import { redirect } from 'next/navigation'
import { getAuth, applyActionCode } from 'firebase/auth'
import { initFirebaseApp } from '@/lib/firebase'
interface PageProps {
  searchParams: Promise<{ oobCode?: string | string[] }>
}
export default async function UpdateEmailPage({ searchParams }: PageProps) {
  const { oobCode: _oobCode } = await searchParams
  const oobCode = typeof _oobCode === 'string' ? _oobCode : undefined
  let error: string | null = null
  if (!oobCode) {
    error = 'Invalid email change link'
  } else {
    try {
      const auth = getAuth(initFirebaseApp())
      await applyActionCode(auth, oobCode)
      redirect('/?emailUpdated=true')
    } catch (err: any) {
      console.error('Error updating email:', err)
      error = 'This email change link is invalid or has expired'
    }
  }
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight">
          Email Change Confirmation
        </h2>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white px-4 py-8 shadow sm:rounded-lg sm:px-10">
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {error}
                </h3>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/verify-email/page.tsx">
import { redirect } from 'next/navigation'
import { getAuth, applyActionCode } from 'firebase/auth'
import { initFirebaseApp } from '@/lib/firebase'
interface PageProps {
  searchParams: Promise<{ oobCode?: string | string[] }>
}
export default async function VerifyEmailPage({ searchParams }: PageProps) {
  const { oobCode: _oobCode } = await searchParams
  const oobCode = typeof _oobCode === 'string' ? _oobCode : undefined
  let error: string | null = null
  if (!oobCode) {
    error = 'Invalid verification link'
  } else {
    try {
      const auth = getAuth(initFirebaseApp())
      await applyActionCode(auth, oobCode)
      redirect('/?verified=true')
    } catch (err: any) {
      console.error('Error verifying email:', err)
      error = 'This verification link is invalid or has expired'
    }
  }
  return (
    <div className="flex min-h-screen flex-col items-center justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight">
          Email Verification
        </h2>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white px-4 py-8 shadow sm:rounded-lg sm:px-10">
          <div className="rounded-md bg-red-50 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-red-800">
                  {error}
                </h3>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/actions.ts">
'use server'
import { signIn, signOut } from "@/lib/auth"
import { getAuth, createUserWithEmailAndPassword, sendPasswordResetEmail, sendEmailVerification, verifyBeforeUpdateEmail } from "firebase/auth"
import { initFirebaseApp } from "@/lib/firebase"
import { APP_URL } from "@/lib/server-constants"
// Common action code settings
const getActionCodeSettings = (action: string) => ({
  url: `${APP_URL}/auth/${action}`,
  handleCodeInApp: true,
  // Optional settings
  iOS: {
    bundleId: 'com.acedzn.dictation'
  },
  android: {
    packageName: 'com.acedzn.dictation',
    installApp: true,
    minimumVersion: '12'
  },
  dynamicLinkDomain: 'acedzn.xyz'
})
export async function handleCredentialsSignIn(email: string, password: string, redirectTo: string) {
  try {
    const result = await signIn("credentials", {
      email,
      password,
      redirect: false,
      redirectTo
    })
    if (result?.error) {
      // Map Firebase error codes to user-friendly messages
      const errorCode = result.error
      let errorMessage = 'An error occurred during sign in'
      switch (errorCode) {
        case 'auth/invalid-credential':
        case 'auth/user-not-found':
        case 'auth/wrong-password':
          errorMessage = 'Invalid email or password'
          break
        case 'auth/invalid-email':
          errorMessage = 'Please enter a valid email address'
          break
        case 'auth/user-disabled':
          errorMessage = 'This account has been disabled'
          break
        case 'auth/too-many-requests':
          errorMessage = 'Too many failed attempts. Please try again later'
          break
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your internet connection'
          break
        case 'auth/popup-closed-by-user':
          errorMessage = 'Sign in was cancelled'
          break
        case 'auth/requires-recent-login':
          errorMessage = 'Please sign in again to continue'
          break
        case 'auth/operation-not-allowed':
          errorMessage = 'Email/password sign in is not enabled'
          break
      }
      return {
        success: false,
        error: errorMessage,
        errorCode // Include the error code for debugging
      }
    }
    return { success: true, redirectTo }
  } catch (error: any) {
    console.error('Sign in error:', error)
    return {
      success: false,
      error: 'An unexpected error occurred. Please try again',
      errorCode: error?.code || 'unknown'
    }
  }
}
export async function handleGoogleSignIn(redirectTo: string) {
  return signIn("google", { redirect: true, redirectTo })
}
export async function handleSignUp(email: string, password: string) {
  try {
    const auth = getAuth(initFirebaseApp())
    await createUserWithEmailAndPassword(auth, email, password)
    return { success: true }
  } catch (error: any) {
    return { success: false, error: error.message }
  }
}
export async function handleSignOut() {
  await signOut({ redirect: true, redirectTo: '/auth/signin' })
}
export async function handlePasswordReset(email: string) {
  try {
    const auth = getAuth(initFirebaseApp())
    await sendPasswordResetEmail(
      auth, 
      email, 
      getActionCodeSettings('reset-password')
    )
    return { 
      success: true,
      message: 'Password reset email sent successfully'
    }
  } catch (error: any) {
    console.error('Password reset error:', error)
    // Map Firebase error codes to user-friendly messages
    let errorMessage = 'Failed to send password reset email'
    switch (error.code) {
      case 'auth/invalid-email':
        errorMessage = 'Please enter a valid email address'
        break
      case 'auth/user-not-found':
        // For security reasons, we don't want to reveal if a user exists or not
        errorMessage = 'If an account exists with this email, you will receive a password reset link'
        break
      case 'auth/too-many-requests':
        errorMessage = 'Too many requests. Please try again later'
        break
      case 'auth/network-request-failed':
        errorMessage = 'Network error. Please check your internet connection'
        break
      case 'auth/unauthorized-continue-uri':
        errorMessage = 'The continue URL provided is not whitelisted'
        console.error('The domain needs to be whitelisted in Firebase Console')
        break
    }
    return {
      success: false,
      error: errorMessage,
      errorCode: error.code
    }
  }
}
export async function handleEmailVerification(user: any) {
  try {
    await sendEmailVerification(
      user,
      getActionCodeSettings('verify-email')
    )
    return {
      success: true,
      message: 'Verification email sent successfully'
    }
  } catch (error: any) {
    console.error('Email verification error:', error)
    return {
      success: false,
      error: 'Failed to send verification email',
      errorCode: error.code
    }
  }
}
export async function handleEmailChange(user: any, newEmail: string) {
  try {
    await verifyBeforeUpdateEmail(
      user,
      newEmail,
      getActionCodeSettings('update-email')
    )
    return {
      success: true,
      message: 'Email change verification sent successfully'
    }
  } catch (error: any) {
    console.error('Email change error:', error)
    let errorMessage = 'Failed to initiate email change'
    switch (error.code) {
      case 'auth/email-already-in-use':
        errorMessage = 'This email is already associated with an account'
        break
      case 'auth/invalid-email':
        errorMessage = 'Please enter a valid email address'
        break
      case 'auth/requires-recent-login':
        errorMessage = 'Please sign in again to change your email'
        break
    }
    return {
      success: false,
      error: errorMessage,
      errorCode: error.code
    }
  }
}
</file>

<file path="src/app/dictation/create/page.tsx">
import { DictationForm } from "@/components/dictation/DictationForm"
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata'
import { getTranslations, getLocale } from 'next-intl/server'
import { Metadata } from 'next'
interface CreateDictationPageProps {
  searchParams: Promise<Record<string, string | string[]>>
}
const getCreateTitle = (locale: string) => {
  const locales =  {
    en: 'Create New Dictation',
    he: 'צור תרגיל הכתבה חדש'
  }
  return locales[locale as keyof typeof locales] as string
}
const getCreateDescription = (locale: string) => {
  const locales =  {
    en: 'Create a new dictation exercise to help others learn languages through interactive text-based learning.',
    he: `צור תרגיל הכתבה חדש כדי לעזור לאחרים ללמוד שפות דרך למידה אינטראקטיבית מבוססת טקסט.`
  }
  return locales[locale as keyof typeof locales] as string
}
export async function generateMetadata(): Promise<Metadata> {
  const locale = await getLocale()
  return generateSiteMetadata(locale, {
    title: getCreateTitle(locale),
    description: getCreateDescription(locale),
    path: '/dictation/create',
    image: '/og/create-dictation.png' // Static image for create page
  })
}
export default async function CreateDictationPage({ searchParams }: CreateDictationPageProps) {
  await searchParams // Need to await even if not using to comply with Next.js 15
  const t = await getTranslations('Dictation.create')
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="space-y-8">
        <div>
          <h1 className="text-2xl font-bold">{t('title')}</h1>
          <p className="text-sm text-gray-500 mt-1">
            {t('description')}
          </p>
        </div>
        <DictationForm />
      </div>
    </div>
  )
}
</file>

<file path="src/app/dictation/edit/[id]/page.tsx">
import { Suspense } from 'react'
import { Spinner } from '@/components/ui/spinner'
import { DictationForm } from '@/components/dictation/DictationForm'
import { getTranslations } from 'next-intl/server'
interface EditDictationPageProps {
  params: Promise<{ id: string }>
}
export default async function EditDictationPage({ params }: EditDictationPageProps) {
  const { id: dictationId } = await params
  const t = await getTranslations('Dictation.edit')
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="space-y-8">
        <div>
          <h1 className="text-2xl font-bold">{t('title')}</h1>
          <p className="text-sm text-gray-500 mt-1">
            {t('description')}
          </p>
        </div>
        <Suspense fallback={<div className="flex justify-center"><Spinner size="lg" /></div>}>
          <DictationForm id={dictationId} />
        </Suspense>
      </div>
    </div>
  )
}
</file>

<file path="src/app/dictation/play/[id]/quiz-game/page.tsx">
import { Metadata } from 'next'
import { getLocale } from 'next-intl/server'
import { getGame } from '@/lib/game'
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata'
import { QuizGameClient } from '@/components/dictation/QuizGameClient'
import { DictationGame } from '@/lib/types'
interface QuizGamePageProps {
  params: Promise<{ id: string }>
}
// Get localized play description
const getPlayDescription = async (locale: string, game: DictationGame) => {
  const locales = {
    en: `Test your knowledge of ${game.targetLanguage} vocabulary with this quiz: ${game.description}`,
    he: `בחן את הידע שלך במילות ה-${game.targetLanguage} עם החידון הזה: ${game.description}`
  }
  return locales[locale as keyof typeof locales] as string
}
export async function generateMetadata({ params }: QuizGamePageProps): Promise<Metadata> {
  const { id: dictationId } = await params
  const locale = await getLocale()
  try {
    const game = await getGame(dictationId)
    const description = await getPlayDescription(locale, game)
    return generateSiteMetadata(locale, {
      title: `${game.title} - Quiz Game`,
      description,
      path: `/dictation/play/${dictationId}/quiz-game`,
      image: `/og/play-dictation.png`
    })
  } catch (error) {
    console.error(error)
    return generateSiteMetadata(locale, {})
  }
}
export default async function QuizGamePage({ params }: QuizGamePageProps) {
  const { id: dictationId } = await params
  try {
    const game = await getGame(dictationId)
    return (
      <div className="container mx-auto px-4 py-8">
        <QuizGameClient game={game} />
      </div>
    )
  } catch (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error instanceof Error ? error.message : 'Failed to load game'}
        </div>
      </div>
    )
  }
}
</file>

<file path="src/app/dictation/play/[id]/writer-game/page.tsx">
import { getGame } from '@/lib/game'
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata'
import { getLocale } from 'next-intl/server'
import { Metadata } from 'next'
import { DictationGame } from '@/lib/types'
import { WriterGameClient } from '@/components/dictation/WriterGameClient'
interface WriterGamePageProps {
  params: Promise<{ id: string }>
}
const getPlayDescription = async (locale: string, game: DictationGame) => {
  const locales = {
    en: `Practice your ${game.targetLanguage} skills with this dictation exercise: ${game.description}`,
    he: `תרגל את כישורי ה-${game.targetLanguage} שלך עם תרגיל ההכתבה הזה: ${game.description}`
  }
  return locales[locale as keyof typeof locales] as string
}
export async function generateMetadata({ params }: WriterGamePageProps): Promise<Metadata> {
  const { id: dictationId } = await params
  const locale = await getLocale()
  try {
    const game = await getGame(dictationId)
    const description = await getPlayDescription(locale, game)
    return generateSiteMetadata(locale, {
      title: `${game.title} - Writer Game`,
      description,
      path: `/dictation/play/${dictationId}/writer-game`,
      image: `/og/play-dictation.png`
    })
  } catch (error) {
    console.error(error)
    return generateSiteMetadata(locale, {})
  }
}
export default async function WriterGamePage({ params }: WriterGamePageProps) {
  const { id: dictationId } = await params
  try {
    const game = await getGame(dictationId)
    return (
      <div className="container mx-auto px-4 py-8">
        <WriterGameClient game={game} />
      </div>
    )
  } catch (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error instanceof Error ? error.message : 'Failed to load game'}
        </div>
      </div>
    )
  }
}
</file>

<file path="src/app/dictation/play/[id]/page.tsx">
import { GameContainer } from '@/components/dictation/GameContainer'
import { getGame } from '@/lib/game'
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata'
import { getLocale } from 'next-intl/server'
import { Metadata } from 'next'
import { DictationGame } from '@/lib/types'
interface PlayDictationPageProps {
  params: Promise<{ id: string }>
}
const getPlayDescription = async (locale: string, game: DictationGame) => {
  const locales =  {
    en: `Practice your ${game.targetLanguage} skills with this dictation exercise: ${game.description}`,
    he: `תרגל את כישורי ה-${game.targetLanguage} שלך עם תרגיל ההכתבה הזה: ${game.description}`
  }
  return locales[locale as keyof typeof locales] as string
}
export async function generateMetadata({ params }: PlayDictationPageProps): Promise<Metadata> {
  const { id: dictationId } = await params
  const locale = await getLocale()
  try {
    const game = await getGame(dictationId)
    const description = await getPlayDescription(locale, game)
    return generateSiteMetadata(locale, {
      title: game.title,
      description,
      path: `/dictation/play/${dictationId}`,
      image: `/og/play-dictation.png` // Dynamic OG image endpoint we'll create later
    })
  } catch (error) {
    console.error(error)
    return generateSiteMetadata(locale, {})
  }
}
export default async function PlayDictationPage({ params }: PlayDictationPageProps) {
  const { id: dictationId } = await params
  try {
    const game = await getGame(dictationId)
    return (
      <div className="container mx-auto px-4 py-8">
        <GameContainer game={game} />
      </div>
    )
  } catch (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error instanceof Error ? error.message : 'Failed to load game'}
        </div>
      </div>
    )
  }
}
</file>

<file path="src/app/privacy-policy/page.tsx">
import type { Metadata } from 'next'
export const metadata: Metadata = {
	title: 'Privacy Policy | Dictation Master',
	description: 'Privacy policy for Dictation Master - How we handle your data'
}
export default function PrivacyPolicy() {
	return (
		<div className="container mx-auto px-4 py-8 max-w-3xl">
			<h1 className="text-3xl font-bold mb-8">Privacy Policy</h1>
			<div className="space-y-6">
				<section>
					<h2 className="text-2xl font-semibold mb-4">Overview</h2>
					<p className="text-gray-700 dark:text-gray-300">
						{`Dictation Master is a personal tool designed to help users practice dictation.
						We are committed to protecting your privacy and being transparent about our practices.`}
					</p>
				</section>
				<section>
					<h2 className="text-2xl font-semibold mb-4">Data Collection</h2>
					<p className="text-gray-700 dark:text-gray-300">
						{`We do not collect or store any personal data about our users. This website
						is designed to be a simple, helpful tool that respects your privacy.`}
					</p>
				</section>
				<section>
					<h2 className="text-2xl font-semibold mb-4">Advertising</h2>
					<p className="text-gray-700 dark:text-gray-300">
						{`We use Google AdSense on our website. Google AdSense may use cookies
						and data to serve personalized ads. This is the only third-party service
						that may collect any information on our website.`}
					</p>
					<p className="text-gray-700 dark:text-gray-300 mt-2">
						{`You can learn more about how Google uses data when you use our site by
						visiting `}<a
							href="https://policies.google.com/technologies/partner-sites"
							className="text-blue-600 dark:text-blue-400 hover:underline"
							target="_blank"
							rel="noopener noreferrer"
						>
							{`Google Privacy & Terms`}
						</a>
						.
					</p>
				</section>
				<section>
					<h2 className="text-2xl font-semibold mb-4">Contact</h2>
					<p className="text-gray-700 dark:text-gray-300">
						{`If you have any questions about this privacy policy, you can reach out
						through our website or GitHub repository.`}
					</p>
				</section>
				<section>
					<h2 className="text-2xl font-semibold mb-4">Changes to This Policy</h2>
					<p className="text-gray-700 dark:text-gray-300">
						{`We may update this privacy policy from time to time. Any changes will be
						reflected on this page.`}
					</p>
				</section>
				<footer className="text-sm text-gray-500 dark:text-gray-400 mt-8">
					{`Last updated: ${new Date().toLocaleDateString()}`}
				</footer>
			</div>
		</div>
	)
}
</file>

<file path="src/app/profile/edit/page.tsx">
import { auth } from "@/lib/auth"
import { redirect } from "next/navigation"
import ProfileForm from "../ProfileForm"
import { getTranslations } from 'next-intl/server'
interface ProfileEditPageProps {
  searchParams: Promise<Record<string, string | string[]>>
}
export default async function ProfileEditPage({ searchParams }: ProfileEditPageProps) {
  const session = await auth()
  if (!session?.user?.id) {
    redirect('/api/auth/signin')
  }
  const t = await getTranslations('Profile')
  await searchParams // Need to await even if not using to comply with Next.js 15
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">{t('editTitle')}</h1>
      <div className="max-w-2xl mx-auto">
        <ProfileForm 
          userId={session.user.id}
          initialName={session.user.name ?? ''}
          initialImage={session.user.image ?? ''}
        />
      </div>
    </div>
  )
}
</file>

<file path="src/app/profile/actions.ts">
'use server'
import { auth } from "@/lib/auth"
import { getAuth } from "firebase-admin/auth"
import { initAdminApp } from "@/lib/firebase-admin"
import { uploadProfileImage, deleteProfileImage } from "@/lib/storage"
import { revalidatePath } from "next/cache"
export async function updateUserProfile(
  userId: string,
  data: {
    firstName?: string
    lastName?: string
    profileImage?: File
    currentImageUrl?: string
  }
) {
  try {
    const session = await auth()
    if (!session?.user || session.user.id !== userId) {
      throw new Error("Unauthorized")
    }
    const adminAuth = getAuth(initAdminApp())
    const updates: { displayName?: string; photoURL?: string } = {}
    // Update name if provided
    if (data.firstName || data.lastName) {
      const displayName = `${data.firstName || ''} ${data.lastName || ''}`.trim()
      if (displayName) {
        updates.displayName = displayName
      }
    }
    // Handle profile image update
    if (data.profileImage) {
      // Upload new image
      const uploadResult = await uploadProfileImage(userId, data.profileImage)
      if (!uploadResult.success) {
        throw new Error(uploadResult.error)
      }
      // Delete old image if exists
      if (data.currentImageUrl) {
        await deleteProfileImage(userId, data.currentImageUrl)
      }
      updates.photoURL = uploadResult.url
    }
    // Update user profile using Admin SDK
    if (Object.keys(updates).length > 0) {
      await adminAuth.updateUser(userId, updates)
      // Get the updated user data
      const updatedUser = await adminAuth.getUser(userId)
      // Force revalidation of the profile page
      revalidatePath('/profile')
      return { 
        success: true,
        user: {
          name: updatedUser.displayName || null,
          image: updatedUser.photoURL || null,
        }
      }
    }
    return { success: true }
  } catch (error: any) {
    console.error("Error updating profile:", error)
    return { success: false, error: error.message }
  }
}
</file>

<file path="src/app/profile/page.tsx">
import { GameCard } from '@/components/dictation/GameCard'
import { getGames, type Game } from '@/app/actions/dictation'
import { auth } from "@/lib/auth"
import { redirect } from "next/navigation"
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { PencilIcon } from '@heroicons/react/24/outline'
import { getTranslations } from 'next-intl/server'
export default async function ProfilePage() {
  const session = await auth()
  if (!session?.user) {
    redirect('/api/auth/signin')
  }
  const games = await getGames()
  const t = await getTranslations('Profile')
  const publishedGames = games.filter((game: Game) => game.isPublic)
  const draftGames = games.filter((game: Game) => !game.isPublic)
  return (
    <div className="container mx-auto py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">{t('title')}</h1>
        <Link href="/profile/edit">
          <Button variant="outline" size="sm" className="gap-2">
            <PencilIcon className="h-4 w-4" />
            {t('editProfile')}
          </Button>
        </Link>
      </div>
      {/* Published Games Section */}
      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">{t('publishedGames')}</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {publishedGames.map((game: Game) => (
            <GameCard key={game.id} {...game} />
          ))}
          {publishedGames.length === 0 && (
            <div className="col-span-full text-center py-8 text-gray-500">
              {t('noPublishedGames')}
            </div>
          )}
        </div>
      </div>
      {/* Draft Games Section */}
      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">{t('draftGames')}</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {draftGames.map((game: Game) => (
            <GameCard 
              key={game.id} 
              {...game}
            />
          ))}
          {draftGames.length === 0 && (
            <div className="col-span-full text-center py-8 text-gray-500">
              {t('noDraftGames')}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/app/profile/ProfileForm.tsx">
"use client"
import { useState, useRef } from "react"
import Image from "next/image"
import { useFormStatus } from "react-dom"
import { updateUserProfile } from "./actions"
import { useSession } from "next-auth/react"
import { useTranslations } from 'next-intl'
function SubmitButton() {
  const { pending } = useFormStatus()
  const t = useTranslations('Profile')
  return (
    <button
      type="submit"
      disabled={pending}
      className="flex justify-center rounded-md bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {pending ? (
        <div className="flex items-center">
          <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          {t('saving')}
        </div>
      ) : (
        t('saveChanges')
      )}
    </button>
  )
}
interface ProfileFormProps {
  userId: string
  initialName: string
  initialImage: string
}
export default function ProfileForm({ userId, initialName, initialImage }: ProfileFormProps) {
  const { update } = useSession()
  const t = useTranslations('Profile')
  const [previewImage, setPreviewImage] = useState<string>(initialImage)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const [firstName, setFirstName] = useState(initialName.split(' ')[0] || '')
  const [lastName, setLastName] = useState(initialName.split(' ')[1] || '')
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)
  const handleImageClick = () => {
    fileInputRef.current?.click()
  }
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      if (file.size > 5 * 1024 * 1024) { // 5MB limit
        setError(t('imageSizeError'))
        return
      }
      const reader = new FileReader()
      reader.onloadend = () => {
        setPreviewImage(reader.result as string)
      }
      reader.readAsDataURL(file)
    }
  }
  async function handleSubmit() {
    setError(null)
    setSuccess(false)
    const file = fileInputRef.current?.files?.[0]
    const result = await updateUserProfile(userId, {
      firstName,
      lastName,
      profileImage: file,
      currentImageUrl: initialImage
    })
    if (result.success) {
      setSuccess(true)
      // Update the session and UI
      if (result.user) {
        // Pass the new data to trigger the update
        await update({
          user: {
            name: result.user.name,
            image: result.user.image
          }
        })
        // Update local state
        setFirstName(result.user.name?.split(' ')[0] || '')
        setLastName(result.user.name?.split(' ')[1] || '')
        if (result.user.image) {
          setPreviewImage(result.user.image)
        }
      }
    } else {
      setError(result.error || t('updateError'))
    }
  }
  return (
    <form action={handleSubmit} className="max-w-xl">
      <div className="space-y-6">
        {/* Profile Image */}
        <div>
          <label className="block text-sm font-medium text-gray-700">{t('profileImage')}</label>
          <div className="mt-2 flex items-center space-x-6">
            <div 
              onClick={handleImageClick}
              className="relative h-24 w-24 cursor-pointer rounded-full overflow-hidden ring-2 ring-gray-200 hover:ring-indigo-500"
            >
              <Image
                src={previewImage || '/default-avatar.png'}
                alt={t('profileImage')}
                fill
                className="object-cover"
              />
            </div>
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleImageChange}
              accept="image/*"
              className="hidden"
            />
            <button
              type="button"
              onClick={handleImageClick}
              className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
            >
              {t('change')}
            </button>
          </div>
        </div>
        {/* Name Fields */}
        <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
          <div>
            <label htmlFor="firstName" className="block text-sm font-medium text-gray-700">
              {t('firstName')}
            </label>
            <input
              type="text"
              id="firstName"
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
            />
          </div>
          <div>
            <label htmlFor="lastName" className="block text-sm font-medium text-gray-700">
              {t('lastName')}
            </label>
            <input
              type="text"
              id="lastName"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm"
            />
          </div>
        </div>
        {/* Error and Success Messages */}
        {error && (
          <div className="rounded-md bg-red-50 p-4">
            <div className="text-sm text-red-700">{error}</div>
          </div>
        )}
        {success && (
          <div className="rounded-md bg-green-50 p-4">
            <div className="text-sm text-green-700">{t('updateSuccess')}</div>
          </div>
        )}
        {/* Submit Button */}
        <div className="flex justify-end">
          <SubmitButton />
        </div>
      </div>
    </form>
  )
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
body {
  font-family: Arial, Helvetica, sans-serif;
}
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
/* Animation keyframes */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
.shake {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
}
/* Font configuration */
.font-alef {
  font-family: 'Alef', sans-serif;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Alef } from "next/font/google";
import "./globals.css";
import { Header } from "@/components/Header";
import { Footer } from "@/components/Footer";
import { auth } from "@/lib/auth";
import { Providers } from "@/components/Providers";
import { NextIntlClientProvider } from 'next-intl';
import { getLangDir } from 'rtl-detect';
import { getLocale, getMessages } from 'next-intl/server';
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata';
import { AdBlockDetector } from '@/components/ui/AdBlockDetector';
const alef = Alef({
  subsets: ["latin"],
  weight: ['400', '700'],
  variable: "--font-alef",
});
export async function generateMetadata(): Promise<Metadata> {
  const locale = await getLocale();
  return generateSiteMetadata(locale);
}
export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const locale = await getLocale();
  const session = await auth();
  const messages = await getMessages();
  const direction = getLangDir(locale);
  return (
    <html lang={locale} className="h-full" dir={direction}>
      <head>
        <script
          async
          src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7458209475481910"
          crossOrigin="anonymous"
        />
      </head>
      <body className={`${alef.variable} font-alef antialiased min-h-screen flex flex-col`}>
        <NextIntlClientProvider messages={messages} locale={locale}>
          <Providers session={session}>
            <div className="flex flex-col min-h-screen">
              <Header />
              <main className="flex-grow">
                <div className="container mx-auto px-4">
                  <AdBlockDetector />
                  {children}
                </div>
              </main>
              <Footer />
            </div>
          </Providers>
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import Link from 'next/link'
import { LatestGames } from '@/components/dictation/LatestGames'
import { getLocale, getTranslations } from 'next-intl/server'
import { getLangDir } from 'rtl-detect';
import { generateMetadata as generateSiteMetadata } from '@/lib/metadata'
import { Metadata } from 'next'
export async function generateMetadata(): Promise<Metadata> {
  const locale = await getLocale()
  return generateSiteMetadata(locale, {
    path: '/',
    image: '/og/home.png' // Static image for home page
  })
}
export default async function Home() {
  const locale = await getLocale();
  const t = await getTranslations();
  const direction = getLangDir(locale);
  return (
    <div className="relative isolate">
      {/* Background gradient */}
      <div
        className="absolute inset-x-0 -top-40 -z-10 transform-gpu overflow-hidden blur-3xl sm:-top-80"
        aria-hidden="true"
      >
        <div
          className="relative left-[calc(50%-11rem)] aspect-[1155/678] w-[36.125rem] -translate-x-1/2 rotate-[30deg] bg-gradient-to-tr from-indigo-200 to-sky-200 opacity-20 sm:left-[calc(50%-30rem)] sm:w-[72.1875rem]"
          style={{
            clipPath:
              'polygon(74.1% 44.1%, 100% 61.6%, 97.5% 26.9%, 85.5% 0.1%, 80.7% 2%, 72.5% 32.5%, 60.2% 62.4%, 52.4% 68.1%, 47.5% 58.3%, 45.2% 34.5%, 27.5% 76.7%, 0.1% 64.9%, 17.9% 100%, 27.6% 76.8%, 76.1% 97.7%, 74.1% 44.1%)',
          }}
        />
      </div>
      {/* Hero section */}
      <div className="px-6 py-24 sm:py-32 lg:px-8">
        <div className="mx-auto max-w-2xl text-center">
          <h1 className="text-4xl font-bold tracking-tight text-gray-900 sm:text-6xl">
            {t('HomePage.title')}
          </h1>
          <p className="mt-6 text-lg leading-8 text-gray-600">
            {t('HomePage.description')}
          </p>
          <div className="mt-10 flex items-center justify-center gap-x-6">
            <Link
              href="/dictation/create"
              className="rounded-md bg-indigo-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
            >
              {t('HomePage.createGame')}
            </Link>
            <Link href="#features" className="text-sm font-semibold leading-6 text-gray-900">
              {t('HomePage.learnMore')} <span aria-hidden="true">{direction === 'rtl' ? '←' : '→'}</span>
            </Link>
          </div>
        </div>
      </div>
      {/* Latest Games Section */}
      <LatestGames />
      {/* Background gradient (bottom) */}
      <div
        className="absolute inset-x-0 top-[calc(100%-13rem)] -z-10 transform-gpu overflow-hidden blur-3xl sm:top-[calc(100%-30rem)]"
        aria-hidden="true"
      >
        <div
          className="relative left-[calc(50%+3rem)] aspect-[1155/678] w-[36.125rem] -translate-x-1/2 bg-gradient-to-tr from-sky-200 to-indigo-200 opacity-20 sm:left-[calc(50%+36rem)] sm:w-[72.1875rem]"
          style={{
            clipPath:
              'polygon(74.1% 44.1%, 100% 61.6%, 97.5% 26.9%, 85.5% 0.1%, 80.7% 2%, 72.5% 32.5%, 60.2% 62.4%, 52.4% 68.1%, 47.5% 58.3%, 45.2% 34.5%, 27.5% 76.7%, 0.1% 64.9%, 17.9% 100%, 27.6% 76.8%, 76.1% 97.7%, 74.1% 44.1%)',
          }}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/components/Adsense/AdUnit.tsx">
'use client'
import { useEffect } from 'react'
interface AdUnitProps {
  adSlot: string
  adFormat?: 'auto' | 'fluid' | 'rectangle' | 'horizontal' | 'vertical'
  style?: React.CSSProperties
}
declare global {
  interface Window {
    adsbygoogle: any[]
  }
}
export const AdUnit = ({ adSlot, adFormat = 'auto', style }: AdUnitProps) => {
  useEffect(() => {
    try {
      if (typeof window !== 'undefined') {
        (window.adsbygoogle = window.adsbygoogle || []).push({})
      }
    } catch (err) {
      console.error('AdSense error:', err)
    }
  }, [])
  return (
    <div style={{ textAlign: 'center', overflow: 'hidden', ...style }}>
      <ins
        className="adsbygoogle"
        style={{ display: 'block' }}
        data-ad-client="ca-pub-7458209475481910"
        data-ad-slot={adSlot}
        data-ad-format={adFormat}
        data-full-width-responsive="true"
      />
    </div>
  )
}
</file>

<file path="src/components/dictation/AdvancedQuizOptions.tsx">
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { Button } from "@/components/ui/button"
import { QuizParameters as QuizParametersType } from "@/lib/types"
import { Label } from "@/components/ui/label"
import { Input } from "@/components/ui/input"
import { Switch } from "@/components/ui/switch"
import { useTranslations } from 'next-intl'
interface AdvancedQuizOptionsProps {
  value: QuizParametersType
  onChange: (value: QuizParametersType) => void
  disabled?: boolean
}
export function AdvancedQuizOptions({ value, onChange, disabled }: AdvancedQuizOptionsProps) {
  const t = useTranslations('Dictation.form')
  const handleChange = (field: keyof QuizParametersType, newValue: number | boolean) => {
    onChange({
      ...value,
      [field]: newValue,
    })
  }
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="outline">{t('advancedMode')}</Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-4">
        <h2 className="text-lg font-semibold mb-4">{t('advancedOptions')}</h2>
        <div className="space-y-6">
          <div className="flex items-center justify-between">
            <Label htmlFor="quiz-mode" className="cursor-pointer">{t('quizMode')}</Label>
            <Switch
              id="quiz-mode"
              checked={value.quizModeEnabled}
              onCheckedChange={checked => handleChange('quizModeEnabled', checked)}
              disabled={disabled}
            />
          </div>
          <div className="space-y-4">
            <div>
              <Label htmlFor="global-time-limit">{t('globalTimeLimit')}</Label>
              <Input
                id="global-time-limit"
                type="number"
                min={0}
                max={120}
                value={value.globalTimeLimit}
                onChange={e => handleChange('globalTimeLimit', parseInt(e.target.value) || 0)}
                className="mt-1"
                disabled={disabled}
              />
            </div>
            <div>
              <Label htmlFor="activity-time-limit">{t('activityTimeLimit')}</Label>
              <Input
                id="activity-time-limit"
                type="number"
                min={0}
                max={300}
                value={value.activityTimeLimit}
                onChange={e => handleChange('activityTimeLimit', parseInt(e.target.value) || 0)}
                className="mt-1"
                disabled={disabled}
              />
            </div>
            <div>
              <Label htmlFor="global-lives-limit">{t('livesLimit')}</Label>
              <Input
                id="global-lives-limit"
                type="number"
                min={1}
                max={10}
                value={value.globalLivesLimit}
                onChange={e => handleChange('globalLivesLimit', parseInt(e.target.value) || 1)}
                className="mt-1"
                disabled={disabled}
              />
            </div>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  )
}
</file>

<file path="src/components/dictation/DictationForm.tsx">
'use client'
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Button } from "@/components/ui/button"
import { Switch } from "@/components/ui/switch"
import { LanguageSelector } from "@/components/dictation/LanguageSelector"
import { WordPairList } from "@/components/dictation/WordPairList"
import { useState, useMemo, useEffect, useCallback } from "react"
import type { CreateDictationInput } from "@/app/actions/dictation"
import type { WordPairsList } from "@/lib/openai"
import { useRouter } from "next/navigation"
import { AdvancedQuizOptions } from "./AdvancedQuizOptions"
import { getLanguageCodeFromName } from "@/lib/utils"
import { Spinner } from "@/components/ui/spinner"
import { ArrowsRightLeftIcon } from "@heroicons/react/24/outline"
import { useTranslations } from 'next-intl'
const DEFAULT_LANGUAGES = {
  source: 'Hebrew',
  target: 'English'
} as const
interface DictationFormProps {
  id?: string
  initialData?: CreateDictationInput & {
    id?: string
    isPublic?: boolean
  }
}
interface FormData extends CreateDictationInput {
  id?: string
  isPublic: boolean
}
export function DictationForm({ id, initialData }: DictationFormProps) {
  const router = useRouter()
  const t = useTranslations('Dictation.form')
  const [formData, setFormData] = useState<FormData>(() => {
    const isPublic = initialData?.isPublic
    return {
      id: initialData?.id,
      title: initialData?.title || '',
      description: initialData?.description,
      sourceLanguage: initialData?.sourceLanguage || DEFAULT_LANGUAGES.source,
      targetLanguage: initialData?.targetLanguage || DEFAULT_LANGUAGES.target,
      wordPairs: initialData?.wordPairs || [{ first: '', second: '', sentence: '' }],
      quizParameters: initialData?.quizParameters || {
        globalTimeLimit: 0,
        globalLivesLimit: 3,
        activityTimeLimit: 30,
        quizModeEnabled: true,
      },
      isPublic: typeof isPublic === 'boolean' ? isPublic : true,
    }
  })
  const [error, setError] = useState<string>()
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)
  const [isProcessingFile, setIsProcessingFile] = useState(false)
  const [isLoading, setIsLoading] = useState(!!id)
  const [selectorKey, setSelectorKey] = useState(0)
  // Fetch data if in edit mode
  useEffect(() => {
    if (!id) return
    async function fetchDictation() {
      try {
        const response = await fetch(`/api/dictation/edit/${id}`)
        if (!response.ok) {
          throw new Error('Failed to fetch dictation')
        }
        const data = await response.json()
        setFormData({
          ...data,
          id: id,
          isPublic: data.isPublic ?? true,
        })
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch dictation')
      } finally {
        setIsLoading(false)
      }
    }
    fetchDictation()
  }, [id])
  const handleGenerateContent = async () => {
    setIsProcessingFile(true)
    try {
      const response = await fetch('/api/dictation/generate-content', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sourceLanguage: getLanguageCodeFromName(formData.sourceLanguage),
          targetLanguage: getLanguageCodeFromName(formData.targetLanguage),
          wordPairs: formData.wordPairs || [],
          title: formData.title || 'NO TITLE',
          description: formData.description || 'NO DESCRIPTION',
          isPublic: formData.isPublic,
        }),
      })
      if (!response.ok) {
        throw new Error('Failed to generate content')
      }
      const data = await response.json()
      setFormData(prev => ({ 
        ...prev, 
        wordPairs: data.wordPairs,
        title: data.title || prev.title,
        description: data.description || prev.description,
      }))
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to generate content')
    } finally {
      setIsProcessingFile(false)
    }
  }
  const handleSaveDraft = async () => {
    setIsSubmitting(true)
    setError(undefined)
    try {
      const response = await fetch('/api/dictation/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...formData,
          isPublic: false, // Force draft to be private
          sourceLanguage: formData.sourceLanguage,
          targetLanguage: formData.targetLanguage,
        }),
      })
      const data = await response.json()
      if (!response.ok) {
        throw new Error(data.error || 'Failed to save draft')
      }
      router.push(`/profile?saved=${data.dictationId}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save draft')
    } finally {
      setIsSubmitting(false)
    }
  }
  const handleDelete = async () => {
    if (!formData.id) return
    setIsDeleting(true)
    setError(undefined)
    try {
      const response = await fetch(`/api/dictation/edit/${formData.id}`, {
        method: 'DELETE',
      })
      if (!response.ok) {
        throw new Error('Failed to delete draft')
      }
      router.push('/profile')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete draft')
    } finally {
      setIsDeleting(false)
    }
  }
  const isFormComplete = useMemo(() => {
    return (
      formData.title.length >= 3 &&
      formData.sourceLanguage &&
      formData.targetLanguage &&
      formData.wordPairs.length > 0 &&
      formData.wordPairs.every(pair => pair.first && pair.second) ? true : false
    )
  }, [formData.title, formData.sourceLanguage, formData.targetLanguage, formData.wordPairs])
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)
    setError(undefined)
    try {
      const url = id ? `/api/dictation/edit/${id}` : '/api/dictation/create'
      const method = id ? 'PUT' : 'POST'
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...formData,
          sourceLanguage: formData.sourceLanguage,
          targetLanguage: formData.targetLanguage,
        }),
      })
      const data = await response.json()
      if (!response.ok) {
        throw new Error(data.error || `Failed to ${id ? 'update' : 'create'} dictation`)
      }
      router.push(`/profile`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unexpected error occurred')
    } finally {
      setIsSubmitting(false)
    }
  }
  const handleFileUploadStart = () => {
    setIsProcessingFile(true)
    setError(undefined)
  }
  const handleFileUploadComplete = (data: WordPairsList) => {
    setFormData(prev => ({ 
      ...prev, 
      wordPairs: data.wordPairs,
      title: data.title || prev.title,
      description: data.description || prev.description || undefined,
    }))
    setIsProcessingFile(false)
  }
  const handleFileUploadError = (error: string) => {
    setError(error)
    setIsProcessingFile(false)
  }
  const handleLanguageSwap = useCallback(() => {
    setFormData(prev => {
      const newWordPairs = prev.wordPairs.map(pair => ({
        first: pair.second,
        second: pair.first,
        sentence: pair.sentence
      }))
      return {
        ...prev,
        sourceLanguage: prev.targetLanguage,
        targetLanguage: prev.sourceLanguage,
        wordPairs: newWordPairs
      }
    })
    setSelectorKey(prev => prev + 1)
  }, [])
  if (isLoading) {
    return (
      <div className="flex justify-center">
        <Spinner size="lg" />
      </div>
    )
  }
  const isLoadingState = isSubmitting || isProcessingFile || isLoading
  return (
    <form onSubmit={handleSubmit} className="space-y-8 bg-white shadow-md rounded-lg p-6">
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}
      {/* Basic Information */}
      <div className="space-y-4">
        <h2 className="text-xl font-semibold text-indigo-600">{t('basicInfo')}</h2>
        <div className="space-y-2">
          <Label htmlFor="title">{t('title')}</Label>
          <Input
            id="title"
            value={formData.title}
            onChange={e => setFormData({ ...formData, title: e.target.value })}
            placeholder={t('titlePlaceholder')}
            maxLength={100}
            required
            disabled={isLoadingState}
            className="transition duration-200 ease-in-out focus:ring-2 focus:ring-indigo-500"
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="description">{t('description')}</Label>
          <Input
            id="description"
            value={formData.description ?? ''}
            onChange={e => setFormData({ ...formData, description: e.target.value || undefined })}
            placeholder={t('descriptionPlaceholder')}
            maxLength={200}
            disabled={isLoadingState}
            className="transition duration-200 ease-in-out focus:ring-2 focus:ring-indigo-500"
          />
        </div>
        <div className="flex items-center space-x-2 gap-2">
          <Switch
            id="public"
            checked={formData.isPublic}
            onCheckedChange={(checked: boolean) => setFormData({ ...formData, isPublic: checked })}
            disabled={isLoadingState}
          />
          <Label htmlFor="public">{t('public')}</Label>
        </div>
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <LanguageSelector
            key={`source-${selectorKey}`}
            id="source-language"
            label={t('sourceLanguage')}
            value={formData.sourceLanguage}
            onChange={value => setFormData({ ...formData, sourceLanguage: value })}
            excludeLanguage={formData.targetLanguage}
            disabled={isLoadingState}
          />
          <div className="flex items-end justify-center">
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={handleLanguageSwap}
              disabled={isLoadingState}
              className="mb-[2px]"
            >
              <ArrowsRightLeftIcon className="h-4 w-4" />
              <span className="sr-only">{t('swapLanguages')}</span>
            </Button>
          </div>
          <LanguageSelector
            key={`target-${selectorKey}`}
            id="target-language"
            label={t('targetLanguage')}
            value={formData.targetLanguage}
            onChange={value => setFormData({ ...formData, targetLanguage: value })}
            excludeLanguage={formData.sourceLanguage}
            disabled={isLoadingState}
          />
        </div>
      </div>
      {/* Word Pairs */}
      <div className="space-y-4">
        <h2 className="text-xl font-semibold text-indigo-600">{t('wordPairs')}</h2>
        <WordPairList
          wordPairs={formData.wordPairs}
          onChange={wordPairs => setFormData({ ...formData, wordPairs })}
          sourceLanguage={formData.sourceLanguage}
          targetLanguage={formData.targetLanguage}
          disabled={isLoadingState}
          onFileUploadStart={handleFileUploadStart}
          onFileUploadComplete={handleFileUploadComplete}
          onFileUploadError={handleFileUploadError}
        />
      </div>
      {/* Advanced Quiz Options */}
      <div className="space-y-4">
        <h2 className="text-xl font-semibold text-indigo-600">{t('advancedOptions')}</h2>
        <AdvancedQuizOptions
          value={formData.quizParameters}
          onChange={quizParameters => setFormData({ ...formData, quizParameters })}
          disabled={isLoadingState}
        />
      </div>
      {/* Form Actions */}
      <div className="flex justify-end gap-4">
        {id ? (
          <>
            <Button
              type="button"
              variant="outline"
              className="transition duration-200 ease-in-out hover:bg-gray-100"
              onClick={() => router.push('/profile')}
              disabled={isLoadingState || isDeleting}
            >
              {t('cancel')}
            </Button>
            {!formData.isPublic && (
              <Button 
                type="button" 
                variant="destructive"
                className="transition duration-200 ease-in-out"
                disabled={isLoadingState || isDeleting}
                onClick={handleDelete}
              >
                {isDeleting ? (
                  <div className="flex items-center gap-2">
                    <Spinner size="sm" />
                    <span>{t('deleting')}</span>
                  </div>
                ) : (
                  t('deleteDraft')
                )}
              </Button>
            )}
            <Button 
              type="submit" 
              className="bg-indigo-600 text-white transition duration-200 ease-in-out hover:bg-indigo-700 min-w-[120px]"
              disabled={isLoadingState || isDeleting || !isFormComplete}
            >
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <Spinner size="sm" />
                  <span>{t('saving')}</span>
                </div>
              ) : (
                t('saveChanges')
              )}
            </Button>
          </>
        ) : (
          <>
            <Button 
              type="button" 
              variant="outline" 
              className="transition duration-200 ease-in-out hover:bg-gray-100"
              disabled={isLoadingState || isFormComplete}
              onClick={handleGenerateContent}
            >
              {isProcessingFile ? (
                <div className="flex items-center gap-2">
                  <Spinner size="sm" />
                  <span>{t('generating')}</span>
                </div>
              ) : (
                t('populateData')
              )}
            </Button>
            <Button 
              type="button" 
              variant="outline" 
              className="transition duration-200 ease-in-out hover:bg-gray-100"
              disabled={isLoadingState}
              onClick={handleSaveDraft}
            >
              {t('saveAsDraft')}
            </Button>
            <Button 
              type="submit" 
              className="bg-indigo-600 text-white transition duration-200 ease-in-out hover:bg-indigo-700 min-w-[120px]"
              disabled={isLoadingState || !isFormComplete}
            >
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <Spinner size="sm" />
                  <span>{t('creating')}</span>
                </div>
              ) : isProcessingFile ? (
                <div className="flex items-center gap-2">
                  <Spinner size="sm" />
                  <span>{t('processingFile')}</span>
                </div>
              ) : (
                t('createDictation')
              )}
            </Button>
          </>
        )}
      </div>
    </form>
  )
}
</file>

<file path="src/components/dictation/FileUpload.tsx">
'use client'
import * as React from "react"
import type { WordPairsList } from "@/lib/openai"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useTranslations } from 'next-intl'
interface FileUploadProps {
  onStart: () => void
  onComplete: (data: WordPairsList) => void
  onError: (error: string) => void
  disabled?: boolean
  sourceLanguage: string
  targetLanguage: string
}
export function FileUpload({ onStart, onComplete, onError, disabled = false, sourceLanguage, targetLanguage }: FileUploadProps) {
  const t = useTranslations('Dictation.form')
  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return
    onStart()
    try {
      const formData = new FormData()
      formData.append('file', file)
      formData.append('firstLanguage', sourceLanguage)
      formData.append('secondLanguage', targetLanguage)
      const response = await fetch('/api/dictation/upload', {
        method: 'POST',
        body: formData,
      })
      if (!response.ok) {
        throw new Error('Failed to upload file')
      }
      const data = await response.json()
      onComplete(data)
    } catch (err) {
      onError(err instanceof Error ? err.message : 'Failed to upload file')
    }
  }
  return (
    <div className="space-y-2">
      <Label htmlFor="file-upload">{t('uploadWordPairs')}</Label>
      <Input
        id="file-upload"
        type="file"
        accept=".txt,.csv,image/*"
        onChange={handleFileChange}
        disabled={disabled}
      />
    </div>
  )
}
</file>

<file path="src/components/dictation/GameCard.tsx">
// src/components/dictation/GameCard.tsx
import { GameCardClient } from '@/components/dictation/GameCardClient'
interface Game {
  id: string
  title: string
  description?: string
  sourceLanguage: string
  targetLanguage: string
  wordPairs: Array<{
    first: string
    second: string
    sentence?: string
  }>
  createdAt: {
    _seconds: number
    _nanoseconds: number
    toDate?: () => Date
  }
  isPublic?: boolean
  playCount?: number
  userId?: string
}
export function GameCard({ 
  id, 
  title, 
  description, 
  sourceLanguage, 
  targetLanguage, 
  wordPairs, 
  createdAt,
  isPublic,
  playCount = 0,
  userId,
}: Game) {
  // Server component that delegates to client component for user-specific actions
  return (
    <div className="overflow-hidden rounded-lg border bg-card text-card-foreground shadow transition-all hover:shadow-md">
      <GameCardClient
        id={id}
        title={title}
        description={description}
        sourceLanguage={sourceLanguage}
        targetLanguage={targetLanguage}
        wordPairs={wordPairs}
        createdAt={createdAt}
        isPublic={isPublic}
        playCount={playCount}
        userId={userId}
      />
    </div>
  )
}
</file>

<file path="src/components/dictation/GameCardClient.tsx">
'use client'
import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { EyeIcon, PencilIcon, TrashIcon, EllipsisVerticalIcon, PlayIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuTrigger 
} from '@/components/ui/dropdown-menu'
import { deleteGame } from '@/app/actions/dictation'
import { useRouter } from 'next/navigation'
import { toast } from 'sonner'
interface Game {
  id: string
  title: string
  description?: string
  sourceLanguage: string
  targetLanguage: string
  wordPairs: Array<{
    first: string
    second: string
    sentence?: string
  }>
  createdAt: {
    _seconds: number
    _nanoseconds: number
    toDate?: () => Date
  }
  isPublic?: boolean
  playCount?: number
  userId?: string
}
export function GameCardClient(props: Game) {
  const { 
    id, 
    title, 
    description, 
    sourceLanguage, 
    targetLanguage, 
    wordPairs, 
    createdAt,
    isPublic,
    playCount = 0,
    userId 
  } = props;
  const router = useRouter();
  const { data: session } = useSession();
  const isOwner = session?.user?.id === userId;
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    // Set isLoading to false after component mounts
    setIsLoading(false);
  }, []);
  const t = useTranslations('Dictation.card')
  const formatDate = (timestamp: Game['createdAt']) => {
    // Check if there's a toDate method and it's callable
    if (timestamp && typeof timestamp.toDate === 'function') {
      try {
        return timestamp.toDate().toLocaleDateString()
      } catch (error) {
        console.error('Error calling toDate():', error)
      }
    }
    // If toDate fails or doesn't exist, try using _seconds
    if (timestamp && typeof timestamp._seconds === 'number') {
      return new Date(timestamp._seconds * 1000).toLocaleDateString()
    }
    // Last resort fallback
    return new Date().toLocaleDateString()
  }
  const handleDelete = async () => {
    try {
      const success = await deleteGame(id)
      if (success) {
        toast.success('Game deleted successfully')
        router.refresh()
      } else {
        toast.error('Failed to delete game')
      }
    } catch (err) {
      toast.error('Failed to delete game: '+err)
    }
  }
  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <div className="h-6 bg-gray-200 rounded animate-pulse mb-2"></div>
          <div className="h-4 bg-gray-200 rounded animate-pulse w-3/4"></div>
        </CardHeader>
        <CardContent>
          <div className="h-4 bg-gray-200 rounded animate-pulse mb-2"></div>
          <div className="h-4 bg-gray-200 rounded animate-pulse w-1/2 mb-2"></div>
          <div className="h-4 bg-gray-200 rounded animate-pulse w-1/4 mb-4"></div>
          <div className="flex gap-2 mt-4">
            <div className="h-9 bg-gray-200 rounded animate-pulse flex-1"></div>
            <div className="h-9 w-9 bg-gray-200 rounded animate-pulse"></div>
          </div>
        </CardContent>
      </Card>
    )
  }
  return (
    <Card className="relative">
        {isOwner && (
            <div className="absolute top-0 left-0">
                <DropdownMenu>
                <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="icon" className="h-8 w-8">
                    <EllipsisVerticalIcon className="h-8 w-8" />
                    <span className="sr-only">Open menu</span>
                    </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => router.push(`/dictation/edit/${id}`)}>
                    <PencilIcon className="h-4 w-4 mr-2" />
                    <span>{t('edit')}</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={handleDelete} className="text-red-600 focus:text-red-600">
                    <TrashIcon className="h-4 w-4 mr-2" />
                    <span>{t('delete')}</span>
                    </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
            </div>
            )}
      <CardHeader>
        <div className="flex justify-between items-start relative">
          <div>
            {isOwner ? isPublic ? (
              <span className="flex items-center gap-1.5 text-green-600 text-xs absolute -top-6 -right-6">
                <span className="h-3 w-3 bg-green-600 rounded-tl-none rounded-b-none rounded-tr-lg rounded-bl-lg"></span>
              </span>
            ) : (
              <span className="flex items-center gap-1.5 text-red-600  text-xs absolute  -top-6 -right-6">
                <span className="h-3 w-3 bg-red-600 rounded-tl-none rounded-b-none rounded-tr-lg rounded-bl-lg"></span>
              </span>
            ) : null}
            <CardTitle className="text-xl font-bold text-center mb-4">{title}</CardTitle>
            {description && <CardDescription>{description}</CardDescription>}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="flex flex-col gap-2">
          <div className="flex justify-between text-sm text-gray-500">
            <div>
              {sourceLanguage} → {targetLanguage}
            </div>
            <div className="flex items-center gap-1">
              <EyeIcon className="h-4 w-4" />
              {playCount}
            </div>
          </div>
          <div className="text-sm text-gray-500">
            {t('words', { count: wordPairs.length })}
          </div>
          <div className="text-xs text-gray-400">
            {t('created')} {formatDate(createdAt)}
          </div>
          <Link href={`/dictation/play/${id}`} className="w-full mt-2">
            <Button className="w-full bg-green-600 hover:bg-green-700">
              <PlayIcon className="h-4 w-4 mr-2" />
              Play
            </Button>
          </Link>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="src/components/dictation/GameContainer.tsx">
'use client'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { DictationGame } from '@/lib/types'
import { Button } from '@/components/ui/button'
import { WordPairDisplay } from '@/components/dictation/WordPairDisplay'
import { useTranslations } from 'next-intl'
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline'
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { PencilIcon, QuestionMarkCircleIcon } from '@heroicons/react/24/outline'
interface GameContainerProps {
  game: DictationGame
}
export function GameContainer({ game }: GameContainerProps) {
  const router = useRouter()
  const [hideExampleSentences, setHideExampleSentences] = useState(true)
  const t = useTranslations('Dictation.game')
  const incrementPlayCount = async () => {
    try {
      const response = await fetch(`/api/dictation/play/${game.id}`, {
        method: 'POST',
      })
      if (!response.ok) {
        console.error('Failed to increment play count')
      }
    } catch (error) {
      console.error('Error incrementing play count:', error)
    }
  }
  const handleWriterGameStart = () => {
    incrementPlayCount()
    router.push(`/dictation/play/${game.id}/writer-game?hideExamples=${hideExampleSentences.toString()}`)
  }
  const handleQuizGameStart = () => {
    incrementPlayCount()
    router.push(`/dictation/play/${game.id}/quiz-game?hideExamples=${hideExampleSentences.toString()}`)
  }
  return (
    <div className="max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-8 text-center">{game.title}</h1>
      <div className="flex justify-end mb-2">
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button 
                variant="ghost" 
                size="icon" 
                onClick={() => setHideExampleSentences(prev => !prev)}
                aria-label={hideExampleSentences ? t('showExamples') : t('hideExamples')}
              >
                {hideExampleSentences ? (
                  <EyeIcon className="h-5 w-5" />
                ) : (
                  <EyeSlashIcon className="h-5 w-5" />
                )}
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              {hideExampleSentences ? t('showExamples') : t('hideExamples')}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
      <WordPairDisplay 
        wordPairs={game.wordPairs} 
        hideSentences={hideExampleSentences}
        sourceLanguage={game.sourceLanguage}
        targetLanguage={game.targetLanguage}
      />
      <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-4 max-w-md mx-auto">
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button 
                size="lg"
                onClick={handleWriterGameStart}
                className="px-8 flex items-center"
              >
                <PencilIcon className="w-5 h-5 mr-2" />
                {t('startWriterGame')}
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              {t('writerGameDescription')}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button 
                size="lg"
                onClick={handleQuizGameStart}
                className="px-8 flex items-center"
                variant="secondary"
              >
                <QuestionMarkCircleIcon className="w-5 h-5 mr-2" />
                {t('startQuizGame')}
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              {t('quizGameDescription')}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    </div>
  )
}
</file>

<file path="src/components/dictation/GameHeader.tsx">
'use client'
import { ForwardedRef, MutableRefObject, forwardRef, useCallback, useImperativeHandle, useRef } from 'react'
import { useAnimate } from 'motion/react'
interface GameHeaderProps {
  hearts: number
  currentWordIndex?: number
  totalWords?: number
  timeLeft: number
  timeLimit?: number
  formatTime: (seconds: number) => string
  heartsContainerRef?: MutableRefObject<HTMLDivElement | null>
  progress?: number
}
export interface GameHeaderRef {
  animateHeartLoss: () => void
}
/**
 * GameHeader - Reusable component for displaying game statistics
 * Includes hearts, progress, and timer
 */
export const GameHeader = forwardRef<GameHeaderRef, GameHeaderProps>(
  function GameHeader(
    {
      hearts,
      currentWordIndex,
      totalWords,
      timeLeft,
      timeLimit,
      formatTime,
      heartsContainerRef,
      progress
    }: GameHeaderProps,
    ref: ForwardedRef<GameHeaderRef>
  ) {
    const [, animate] = useAnimate()
    const internalHeartsContainerRef = useRef<HTMLDivElement>(null)
    const heartsRef = heartsContainerRef || internalHeartsContainerRef
    const animateHeartLoss = useCallback(() => {
      if (!heartsRef.current) return
      // Create a falling heart element
      const fallingHeart = document.createElement('div')
      fallingHeart.innerHTML = '❤️'
      fallingHeart.className = 'absolute text-lg leading-none pointer-events-none z-10 origin-center'
      fallingHeart.style.willChange = 'transform, opacity'
      // Get the heart element position
      const heartElement = heartsRef.current.querySelector('.heart')
      if (!heartElement) return
      const heartRect = heartElement.getBoundingClientRect()
      const containerRect = heartsRef.current.getBoundingClientRect()
      // Add the falling heart to the container
      heartsRef.current.appendChild(fallingHeart)
      // Position the falling heart exactly over the heart display
      fallingHeart.style.left = `${heartRect.left - containerRect.left}px`
      fallingHeart.style.top = `${heartRect.top - containerRect.top}px`
      // Animate the falling heart
      animate([
        [
          fallingHeart,
          {
            transform: [
              'translate(0, 0) rotate(0deg) scale(1)',
              `translate(${Math.random() * 100 - 50}px, ${window.innerHeight}px) rotate(${Math.random() * 360}deg) scale(0.5)`
            ],
            opacity: [1, 0]
          },
          {
            duration: 5,
            ease: [0.23, 1, 0.32, 1], // Cubic bezier for natural falling motion
            onComplete: () => fallingHeart.remove()
          }
        ]
      ])
    }, [animate, heartsRef])
    // Expose the animateHeartLoss function to parent components
    useImperativeHandle(ref, () => ({
      animateHeartLoss
    }))
    // Calculate effective time limit (default to 60s if not provided)
    const effectiveTimeLimit = timeLimit ?? 60
    return (
      <div className="flex justify-between items-center mb-12 relative text-lg font-bold w-full">
        {/* Hearts Container */}
        <div ref={heartsRef} className="relative flex items-center gap-2">
          <div className="flex items-center gap-2">
            <span className="heart animate-pulse">❤️</span>
            <span className="heart-count">{hearts}</span>
          </div>
        </div>
        {/* Progress */}
        <div className="">
          {currentWordIndex !== undefined && totalWords !== undefined ? (
            `${currentWordIndex}/${totalWords}`
          ) : progress !== undefined ? (
            `${progress}%`
          ) : null}
        </div>
        {/* Timer */}
        <div className="absolute left-1/2 -translate-x-1/2 top-1/2 -translate-y-1/2 flex flex-col items-center">
          <div className="w-32 h-2 bg-gray-200 rounded-full overflow-hidden">
            <div 
              className="h-full bg-indigo-600 transition-all duration-1000 ease-linear"
              style={{ 
                width: `${(timeLeft / effectiveTimeLimit) * 100}%`,
                backgroundColor: timeLeft <= 5 ? '#ef4444' : undefined
              }}
            />
          </div>
          <div className="font-mono mt-2">
            {formatTime(timeLeft)}
          </div>
        </div>
      </div>
    )
  }
)
</file>

<file path="src/components/dictation/GameOverView.tsx">
'use client'
import { ClockIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
interface GameOverViewProps {
  stars: number
  hearts?: number
  totalTime: number
  fails?: number
  completedWords: number
  totalWords?: number
  onPlayAgain: () => void
  onExit: () => void
}
/**
 * GameOverView - Reusable component for displaying the game over screen
 * Shows star rating, hearts remaining, time spent, and score
 */
export function GameOverView({
  stars,
  hearts = 0,
  totalTime,
  fails = 0,
  completedWords,
  totalWords,
  onPlayAgain,
  onExit
}: GameOverViewProps) {
  const t = useTranslations('Dictation.game')
  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`
  }
  return (
    <div className="max-w-md mx-auto text-center p-8 bg-white rounded-xl shadow-2xl">
      <h2 className="text-4xl font-bold mb-6 text-indigo-600">{t('gameOver')}</h2>
      <div className="space-y-6 grid">
        <div className="text-6xl mb-6">
          <div className="flex items-center justify-center gap-4">
            <span className={`text-6xl transition-all ${stars >= 1 ? 'text-yellow-400' : 'text-gray-300 [filter:grayscale(100%)]'}`}>⭐</span>
            <span className={`text-8xl transition-all ${stars === 3 ? 'text-yellow-400' : 'text-gray-300 [filter:grayscale(100%)]'}`}>⭐</span>
            <span className={`text-6xl transition-all ${stars >= 2 ? 'text-yellow-400' : 'text-gray-300 [filter:grayscale(100%)]'}`}>⭐</span>
          </div>
        </div>
        <div className="flex flex-col gap-4">
          <div className="grid gap-4 text-xl" style={{ gridTemplateColumns: '1fr 1fr' }}>
            <p className="flex justify-end items-center text-3xl">❤️</p>
            <p className="flex justify-start items-center">{hearts}</p>
          </div>
          <div className="grid gap-4 text-xl" style={{ gridTemplateColumns: '1fr 1fr' }}>
            <p className="flex justify-end items-center"><ClockIcon className="h-8 w-8" /></p>
            <p className="flex justify-start items-center">{formatTime(totalTime)}</p>
          </div>
          <div className="grid gap-4 text-xl" style={{ gridTemplateColumns: '1fr auto 1fr' }}>
            <p className="justify-end items-center flex">{fails}</p>
            <p className="text-center items-center flex">/</p>
            <p className="justify-start items-center flex">
              {totalWords ? `${completedWords}/${totalWords}` : completedWords}
            </p>
          </div>
        </div>
        <div className="mt-8 flex flex-row gap-4 justify-center items-center">
          <button
            onClick={onPlayAgain}
            className="bg-indigo-600 text-white px-8 py-3 rounded-xl text-lg font-bold hover:bg-indigo-700 transform hover:scale-105 transition-all shadow-lg"
          >
            {t('playAgain')}
          </button>
          <button
            onClick={onExit}
            className="bg-gray-600 text-white px-8 py-3 rounded-xl text-lg font-bold hover:bg-gray-700 transform hover:scale-105 transition-all shadow-lg"
          >
            {t('exit')}
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/dictation/GameView.tsx">
// src/components/dictation/GameView.tsx
'use client'
import { useState, useEffect, useRef, useMemo } from 'react'
import { DictationGame, WordPair } from '@/lib/types'
import { Input } from '@/components/ui/input'
import Realistic from 'react-canvas-confetti/dist/presets/realistic'
import { useAnimate } from 'motion/react'
import {  EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline'
import { useCallback } from 'react'
import { useTranslations } from 'next-intl'
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { Button } from '@/components/ui/button'
import { GameOverView } from './GameOverView'
import { GameHeader, GameHeaderRef } from './GameHeader'
interface GameViewProps {
  game: DictationGame
  onGameEnd: () => void
  hideExampleSentences?: boolean
  onToggleExampleSentences?: () => void
}
interface GameState {
  currentWordIndex: number
  hearts: number
  timeLeft: number
  gameStartTime: number
  totalTime: number
  isGameOver: boolean
  stars: number
  fails: number
  isPaused: boolean
  completedWords: number
  currentWordGuesses: number
}
export function GameView({ 
  game, 
  onGameEnd,
  hideExampleSentences = false,
  onToggleExampleSentences
}: GameViewProps) {
  const t = useTranslations('Dictation.game')
  // Randomize word pairs on initial load
  const randomizedWordPairs = useMemo(() => {
    return [...game.wordPairs].sort(() => Math.random() - 0.5)
  }, [game.wordPairs])
  const [gameState, setGameState] = useState<GameState>({
    currentWordIndex: 0,
    hearts: game.quizParameters.globalLivesLimit,
    timeLeft: game.quizParameters.activityTimeLimit,
    gameStartTime: Date.now(),
    totalTime: 0,
    isGameOver: false,
    stars: 3,
    fails: 0,
    isPaused: false,
    completedWords: 0,
    currentWordGuesses: 0
  })
  const [input, setInput] = useState('')
  const [inputStatus, setInputStatus] = useState<'default' | 'correct' | 'incorrect'>('default')
  const [hasInputChanged, setHasInputChanged] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)
  const confettiController = useRef<any>(null)
  const heartsContainerRef = useRef<HTMLDivElement>(null)
  const gameHeaderRef = useRef<GameHeaderRef>(null)
  // eslint-disable-next-line 
  const [scope, animate] = useAnimate()
  const endGame = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      isGameOver: true,
      totalTime: Math.floor((Date.now() - prev.gameStartTime) / 1000)
    }))
  }, [])
  const handleConfettiInit = useCallback(({ conductor }: { conductor: any }) => {
    confettiController.current = conductor
  }, [])
  const restartGame = useCallback(() => {
    setGameState({
      currentWordIndex: 0,
      hearts: game.quizParameters.globalLivesLimit,
      timeLeft: game.quizParameters.activityTimeLimit,
      gameStartTime: Date.now(),
      totalTime: 0,
      isGameOver: false,
      stars: 3,
      fails: 0,
      isPaused: false,
      completedWords: 0,
      currentWordGuesses: 0
    })
    setInput('')
    setInputStatus('default')
    setHasInputChanged(false)
  }, [game.quizParameters.globalLivesLimit, game.quizParameters.activityTimeLimit])
  const formatTime = useCallback((seconds: number): string => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`
  }, [])
  const getCurrentWord = useCallback((): WordPair => randomizedWordPairs[gameState.currentWordIndex], [randomizedWordPairs, gameState.currentWordIndex])
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    setInput(value)
    setHasInputChanged(true)
    // Check if the answer is correct on change
    if (value.toLowerCase().trim() === getCurrentWord().second.toLowerCase().trim()) {
      handleCorrectAnswer()
    }
  }
  const handleInputBlur = () => {
    if (!gameState.isGameOver && hasInputChanged) {
      validateAnswer()
      setHasInputChanged(false)
    }
  }
  const handleInputKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && hasInputChanged) {
      validateAnswer()
      setHasInputChanged(false)
    }
  }
  // Extracted moveToNextWord logic into a separate function
  const moveToNextWord = useCallback(() => {
    const nextIndex = gameState.currentWordIndex + 1
    if (nextIndex >= game.wordPairs.length) {
      setTimeout(() => {
        endGame()
      }, 1000) // Add delay before game end
    } else {
      setGameState(prev => ({
        ...prev,
        currentWordIndex: nextIndex,
        timeLeft: game.quizParameters.activityTimeLimit,
        isPaused: false,
        currentWordGuesses: 0
      }))
      setInput('')
      setInputStatus('default')
    }
  }, [endGame, gameState.currentWordIndex, game.wordPairs.length, game.quizParameters.activityTimeLimit])
  const handleCorrectAnswer = useCallback(() => {
    setInputStatus('correct')
    setHasInputChanged(false)
    confettiController.current?.shoot()
    // Pause the timer immediately
    setGameState(prev => ({ ...prev, isPaused: true, completedWords: prev.completedWords + 1 }))
    // Play audio if available and move to next word after completion
    const currentWord = getCurrentWord()
    if (currentWord.secondAudioUrl) {
      const audio = new Audio(currentWord.secondAudioUrl)
      audio.addEventListener('ended', () => {
        moveToNextWord()
      })
      audio.play().catch(error => {
        console.error('Error playing audio:', error)
        moveToNextWord() // Move to next word even if audio fails
      })
    } else {
      // If no audio, wait for a moment before moving to next word
      setTimeout(moveToNextWord, 1000)
    }
  }, [ getCurrentWord, moveToNextWord])
  const getHint = useCallback((word: string, guessCount: number) => {
    const revealed = word.slice(0, Math.min(guessCount + 1, word.length))
    const hidden = '_'.repeat(Math.max(0, word.length - revealed.length))
    return revealed + hidden
  }, [])
  const handleIncorrectAnswer = useCallback((isTimeOut: boolean = false) => {
    setInputStatus('incorrect')
    const newHearts = gameState.hearts - 1
    const newFails = gameState.fails + 1
    const newGuesses = gameState.currentWordGuesses + 1
    // Only animate heart loss if we still have hearts
    if (gameState.hearts > 0) {
      gameHeaderRef.current?.animateHeartLoss()
    }
    let newStars = 3
    if (newFails >= 5) newStars = 1
    else if (newFails >= 3) newStars = 2
    setGameState(prev => ({
      ...prev,
      hearts: newHearts,
      fails: newFails,
      stars: newStars,
      currentWordGuesses: newGuesses,
      timeLeft: isTimeOut ? game.quizParameters.activityTimeLimit : prev.timeLeft
    }))
    if (newHearts <= 0) {
      endGame()
    } else {
      setTimeout(() => {
        setInputStatus('default')
        inputRef.current?.focus()
      }, 500)
    }
  }, [endGame, gameState.hearts, gameState.fails, gameState.currentWordGuesses, game.quizParameters.activityTimeLimit])
  const validateAnswer = useCallback(() => {
    const isCorrect = input.toLowerCase().trim() === getCurrentWord().second.toLowerCase().trim()
    if (isCorrect) {
      handleCorrectAnswer()
    } else {
      handleIncorrectAnswer()
    }
  }, [input, getCurrentWord, handleCorrectAnswer, handleIncorrectAnswer])
  // Timer effect
  useEffect(() => {
    if (gameState.isGameOver || !game.quizParameters.activityTimeLimit || gameState.isPaused) return
    const timer = setInterval(() => {
      if (gameState.timeLeft <= 0) {
        handleIncorrectAnswer(true)
      } else {
        setGameState(prev => ({ ...prev, timeLeft: prev.timeLeft - 1 }))
      }
    }, 1000)
    return () => clearInterval(timer)
  }, [handleIncorrectAnswer, gameState.isGameOver, game.quizParameters.activityTimeLimit, gameState.timeLeft, gameState.isPaused])
  // Auto-focus effect
  useEffect(() => {
    if (!gameState.isGameOver) {
      inputRef.current?.focus()
    }
  }, [gameState.currentWordIndex, gameState.isGameOver])
  if (gameState.isGameOver) {
    return (
      <GameOverView 
        stars={gameState.stars}
        hearts={gameState.hearts}
        totalTime={gameState.totalTime}
        fails={gameState.fails}
        completedWords={gameState.completedWords}
        onPlayAgain={restartGame}
        onExit={onGameEnd}
      />
    )
  }
  return (
    <div className="max-w-3xl mx-auto p-6">
      <Realistic onInit={handleConfettiInit} />
      <h1 className="text-md mb-12 text-center text-gray-300 relative">
        {game.title}
        {/* Example Sentences Toggle */}
        {onToggleExampleSentences && (
          <Button
            variant="ghost"
            size="icon"
            onClick={onToggleExampleSentences}
            className="absolute right-0 top-1/2 -translate-y-1/2"
            title={hideExampleSentences ? t('showExamples') : t('hideExamples')}
          >
            {hideExampleSentences ? (
              <EyeSlashIcon className="h-5 w-5" />
            ) : (
              <EyeIcon className="h-5 w-5" />
            )}
          </Button>
        )}
      </h1>
      <GameHeader 
        ref={gameHeaderRef}
        hearts={gameState.hearts}
        currentWordIndex={gameState.currentWordIndex}
        totalWords={game.wordPairs.length}
        timeLeft={gameState.timeLeft}
        timeLimit={game.quizParameters.activityTimeLimit}
        formatTime={formatTime}
        heartsContainerRef={heartsContainerRef}
      />
      <div className="text-center mb-12 w-full min-h-[50vh] flex flex-col justify-center items-center">
        <div className="flex flex-col justify-center items-center h-auto">
          <div className="text-6xl font-bold mb-12 text-indigo-600">
            {getCurrentWord().first}
          </div>
          <div className="flex justify-center items-center">
            <div className="flex flex-col justify-center items-center relative">
              <Input
                ref={inputRef}
                value={input}
                onChange={handleInputChange}
                onBlur={handleInputBlur}
                onKeyDown={handleInputKeyDown}
                maxLength={getCurrentWord().second.length}
                className={`text-center text-xl md:text-4xl font-bold p-6 rounded-xl border-2 shadow-lg h-fit w-auto transition-all duration-300 ease-in-out transform preserve-3d hover:scale-105 focus:scale-105 ${
                  inputStatus === 'correct' ? 'bg-green-50 border-green-500 scale-105' :
                  inputStatus === 'incorrect' ? 'bg-red-50 border-red-500 shake' :
                  'border-indigo-200 hover:border-indigo-400 focus:border-indigo-600'
                }`}
                autoComplete="off"
                style={{
                  transformStyle: 'preserve-3d',
                  transform: 'perspective(1000px) rotateX(2deg)',
                }}
              />
              {gameState.currentWordGuesses > 0 && inputStatus !== 'correct' && (
                <TooltipProvider>
                  <Tooltip open={true}>
                    <TooltipTrigger asChild>
                      <div className="absolute -bottom-20 left-1/2 transform -translate-x-1/2 w-1 h-1" />
                    </TooltipTrigger>
                    <TooltipContent 
                      className="bg-red-500 text-white font-mono text-lg px-4 py-2 shadow-lg relative overflow-visible"
                      sideOffset={16}
                    >
                      <div className="absolute -top-2 left-1/2 -translate-x-1/2 w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-b-[8px] border-b-red-500" />
                      {getHint(getCurrentWord().second, gameState.currentWordGuesses - 1)}
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              )}
            </div>
          </div>
          <div className={`example-sentence text-xl text-gray-600 mt-20 transition-opacity duration-300 ${hideExampleSentences ? 'opacity-0' : 'opacity-100'}`}>
            {getCurrentWord().sentence}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/dictation/LanguageSelector.tsx">
'use client'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { useTranslations } from 'next-intl'
const LANGUAGES = [
  'English',
  'Hebrew',
  'Spanish',
  'French',
  'German',
  'Italian',
  'Portuguese',
  'Russian',
  'Chinese',
  'Japanese',
  'Korean',
  'Arabic'
] as const
interface LanguageSelectorProps {
  id: string
  label: string
  value: string
  onChange: (value: string) => void
  excludeLanguage?: string
  error?: string
  disabled?: boolean
}
export function LanguageSelector({
  id,
  label,
  value,
  onChange,
  excludeLanguage,
  error,
  disabled = false
}: LanguageSelectorProps) {
  const t = useTranslations('Language')
  return (
    <div className="space-y-2">
      <Label htmlFor={id}>{label}</Label>
      <Select
        value={value}
        onValueChange={onChange}
        disabled={disabled}
      >
        <SelectTrigger id={id}>
          <SelectValue>{t(`languages.${value}`)}</SelectValue>
        </SelectTrigger>
        <SelectContent>
          {LANGUAGES.filter(lang => lang !== excludeLanguage).map((language) => (
            <SelectItem key={language} value={language}>
              {t(`languages.${language}`)}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {error && <p className="text-sm text-red-500">{error}</p>}
    </div>
  )
}
</file>

<file path="src/components/dictation/LatestGames.tsx">
import { GameCard } from '@/components/dictation/GameCard'
import { Game } from '@/app/actions/dictation'
import { APP_URL } from '@/lib/server-constants'
import { getTranslations } from 'next-intl/server'
async function getLatestGames(): Promise<Game[]> {
  const response = await fetch(`${APP_URL}/api/dictation/latest`, {
    cache: 'no-store'
  })
  if (!response.ok) {
    throw new Error('Failed to fetch latest games')
  }
  const data = await response.json()
  console.log('DEBUG - Raw data from API:', data.games[0]?.createdAt)
  // Return the games directly without transforming the timestamp
  // The API is already sending the data in the correct format
  return data.games;
}
export async function LatestGames() {
  const t = await getTranslations("LatestGames")
  let games = [] as any;
  try {
  games = await getLatestGames()
  //console.log('games', games)
  if (!games.length) {
    return null
  }
} catch(error){
  console.log('error occured', error)
  return null
}
  return (
    <section className="py-12 sm:py-16">
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="mx-auto max-w-2xl text-center">
          <h2 className="text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl">
            {t('title')}
          </h2>
          <p className="mt-2 text-lg leading-8 text-gray-600">
            {t('description')}
          </p>
        </div>
        <div className="mx-auto mt-16 grid max-w-2xl grid-cols-1 gap-6 sm:grid-cols-2 lg:mx-0 lg:max-w-none lg:grid-cols-3">
          {games.map((game:any) => (
            <GameCard key={game.id} {...game} />
          ))}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="src/components/dictation/QuizGameClient.tsx">
'use client'
import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { DictationGame } from '@/lib/types'
import { Button } from '@/components/ui/button'
import { ArrowLeftIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
import { QuizGameView } from './QuizGameView'
interface QuizGameClientProps {
  game: DictationGame
}
export function QuizGameClient({ game }: QuizGameClientProps) {
  const searchParams = useSearchParams()
  const hideExamplesParam = searchParams.get('hideExamples')
  const [hideExampleSentences, setHideExampleSentences] = useState(
    hideExamplesParam === 'true' || hideExamplesParam === null
  )
  const [showBackButton, setShowBackButton] = useState(true)
  const router = useRouter()
  const t = useTranslations('Dictation.game')
  // Hide back button after 5 seconds
  useEffect(() => {
    if (showBackButton) {
      const timer = setTimeout(() => {
        setShowBackButton(false)
      }, 5000)
      return () => clearTimeout(timer)
    }
  }, [showBackButton])
  const handleGameEnd = () => {
    router.push(`/dictation/play/${game.id}`)
  }
  const handleBackClick = () => {
    router.push(`/dictation/play/${game.id}`)
  }
  const handleToggleExampleSentences = () => {
    setHideExampleSentences(!hideExampleSentences)
  }
  return (
    <div className="relative">
      {showBackButton && (
        <Button
          variant="outline"
          size="sm"
          className="absolute top-0 left-0 z-10"
          onClick={handleBackClick}
        >
          <ArrowLeftIcon className="w-4 h-4 mr-2" />
          {t('back')}
        </Button>
      )}
      <QuizGameView
        game={game}
        onGameEnd={handleGameEnd}
        hideExampleSentences={hideExampleSentences}
        onToggleExampleSentences={handleToggleExampleSentences}
      />
    </div>
  )
}
</file>

<file path="src/components/dictation/QuizGameView.tsx">
'use client'
import { useState, useEffect, useRef, useMemo, useCallback } from 'react'
import { DictationGame, WordPair } from '@/lib/types'
import Realistic from 'react-canvas-confetti/dist/presets/realistic'
import { useAnimate } from 'motion/react'
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { Button } from '@/components/ui/button'
import { GameOverView } from './GameOverView'
import { GameHeader, GameHeaderRef } from './GameHeader'
import { toast } from 'sonner'
interface QuizGameViewProps {
  game: DictationGame
  onGameEnd: () => void
  hideExampleSentences?: boolean
  onToggleExampleSentences?: () => void
}
interface GameState {
  currentWordIndex: number
  hearts: number
  timeLeft: number
  gameStartTime: number
  totalTime: number
  isGameOver: boolean
  stars: number
  fails: number
  isPaused: boolean
  completedWords: number
  selectedOption: number | null
  mistakesOnCurrentWord: number
}
interface QuizOption {
  value: string
  isCorrect: boolean
}
export function QuizGameView({ 
  game, 
  onGameEnd,
  hideExampleSentences = false,
  onToggleExampleSentences
}: QuizGameViewProps) {
  const t = useTranslations('Dictation.game')
  // Randomize word pairs on initial load
  const randomizedWordPairs = useMemo(() => {
    return [...game.wordPairs].sort(() => Math.random() - 0.5)
  }, [game.wordPairs])
  const [gameState, setGameState] = useState<GameState>({
    currentWordIndex: 0,
    hearts: game.quizParameters.globalLivesLimit,
    timeLeft: game.quizParameters.activityTimeLimit,
    gameStartTime: Date.now(),
    totalTime: 0,
    isGameOver: false,
    stars: 3,
    fails: 0,
    isPaused: false,
    completedWords: 0,
    selectedOption: null,
    mistakesOnCurrentWord: 0
  })
  const [quizOptions, setQuizOptions] = useState<QuizOption[]>([])
  const [showCorrectAnswer, setShowCorrectAnswer] = useState(false)
  const [ , setIsAudioLoading] = useState(false)
  const [ , setAudioError] = useState<string | null>(null)
  const confettiController = useRef<any>(null)
  const gameHeaderRef = useRef<GameHeaderRef>(null)
  // eslint-disable-next-line 
  const [scope, animate] = useAnimate()
  const endGame = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      isGameOver: true,
      totalTime: Math.floor((Date.now() - prev.gameStartTime) / 1000)
    }))
  }, [])
  const handleConfettiInit = useCallback(({ conductor }: { conductor: any }) => {
    confettiController.current = conductor
  }, [])
  const getCurrentWord = useCallback((): WordPair => 
    randomizedWordPairs[gameState.currentWordIndex], 
    [randomizedWordPairs, gameState.currentWordIndex]
  )
  const generateOptions = useCallback(() => {
    const currentWord = getCurrentWord()
    const correctOption = { value: currentWord.second, isCorrect: true }
    // Generate 2 wrong options from other word pairs
    const availableOptions = randomizedWordPairs
      .filter((_, index) => index !== gameState.currentWordIndex)
      .map(pair => pair.second)
    // Shuffle and take first 2
    const wrongOptions = [...availableOptions]
      .sort(() => Math.random() - 0.5)
      .slice(0, 2)
      .map(value => ({ value, isCorrect: false }))
    // Combine correct and wrong options, then shuffle
    const allOptions = [correctOption, ...wrongOptions].sort(() => Math.random() - 0.5)
    setQuizOptions(allOptions)
  }, [getCurrentWord, gameState.currentWordIndex, randomizedWordPairs, setQuizOptions])
  const restartGame = useCallback(() => {
    setGameState({
      currentWordIndex: 0,
      hearts: game.quizParameters.globalLivesLimit,
      timeLeft: game.quizParameters.activityTimeLimit,
      gameStartTime: Date.now(),
      totalTime: 0,
      isGameOver: false,
      stars: 3,
      fails: 0,
      isPaused: false,
      completedWords: 0,
      selectedOption: null,
      mistakesOnCurrentWord: 0
    })
    setShowCorrectAnswer(false)
    generateOptions()
  }, [game.quizParameters.globalLivesLimit, game.quizParameters.activityTimeLimit, generateOptions])
  const formatTime = useCallback((seconds: number): string => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`
  }, [])
  // Generate options when the current word changes
  useEffect(() => {
    generateOptions()
  }, [gameState.currentWordIndex, generateOptions])
  const moveToNextWord = useCallback(() => {
    const nextIndex = gameState.currentWordIndex + 1
    if (nextIndex >= game.wordPairs.length) {
      setTimeout(() => {
        endGame()
      }, 1000) // Add delay before game end
    } else {
      setGameState(prev => ({
        ...prev,
        currentWordIndex: nextIndex,
        timeLeft: game.quizParameters.activityTimeLimit,
        isPaused: false,
        selectedOption: null,
        mistakesOnCurrentWord: 0
      }))
      setShowCorrectAnswer(false)
    }
  }, [endGame, gameState.currentWordIndex, game.wordPairs.length, game.quizParameters.activityTimeLimit])
  const playSecondAudio = useCallback(async () => {
    const currentWord = getCurrentWord();
    if (!currentWord.secondAudioUrl) {
      // If no audio URL is available, resolve after a short delay
      return new Promise<void>(resolve => setTimeout(resolve, 500));
    }
    setIsAudioLoading(true);
    setAudioError(null);
    try {
      // Try to refresh the audio URL before playing
      // Play the audio with the fresh URL
      const audio = new Audio(currentWord?.secondAudioUrl);
      // Add event listener for when audio finishes playing
      audio.addEventListener('ended', () => {
        setIsAudioLoading(false);
      });
      // Handle audio errors
      audio.addEventListener('error', (e) => {
        console.error('Error playing audio:', e);
        setIsAudioLoading(false);
      });
      // Play the audio
      await audio.play();
    } catch (error) {
      console.error('Error refreshing audio URL:', error);
      setAudioError("Audio preparation failed");
      toast.error("There was an error preparing the audio");
      setIsAudioLoading(false);
    }
  }, [getCurrentWord])
  const handleOptionSelect = useCallback((optionIndex: number) => {
    const isCorrect = quizOptions[optionIndex].isCorrect
    setGameState(prev => ({ 
      ...prev, 
      selectedOption: optionIndex,
      isPaused: true
    }))
    if (isCorrect) {
      confettiController.current?.shoot()
      setGameState(prev => ({ 
        ...prev, 
        completedWords: prev.completedWords + 1
      }))
      // Play audio if available and move to next word after completion
      playSecondAudio().then(() => {
        setShowCorrectAnswer(false)
        moveToNextWord()
      })
    } else {
      // Incorrect answer
      setGameState(prev => {
        const newMistakesOnCurrentWord = prev.mistakesOnCurrentWord + 1
        const newHearts = prev.hearts - 1
        const newFails = prev.fails + 1
        // Only animate heart loss if we still have hearts
        if (prev.hearts > 0) {
          gameHeaderRef.current?.animateHeartLoss()
        }
        let newStars = 3
        if (newFails >= 5) newStars = 1
        else if (newFails >= 3) newStars = 2
        // Store these values to use in the setTimeout
        const updatedHearts = newHearts
        const updatedMistakes = newMistakesOnCurrentWord
        // Use setTimeout to determine next steps
        setTimeout(() => {
          if (updatedHearts <= 0) { // If this was the last heart
            endGame()
          } else if (updatedMistakes >= 2) { 
            // This is the second mistake on this word
            // Show correct answer and play audio before proceeding
            setShowCorrectAnswer(true)
            // Find the correct option index
            const correctOptionIndex = quizOptions.findIndex(option => option.isCorrect)
            // Set the correct option as selected
            setGameState(prevState => ({ 
              ...prevState, 
              selectedOption: correctOptionIndex
            }))
            // Play the audio and then move to next word
            playSecondAudio().then(() => {
              setShowCorrectAnswer(false)
              moveToNextWord()
            })
          } else {
            // First mistake, reset selection and allow another try
            setGameState(prevState => ({ 
              ...prevState, 
              selectedOption: null,
              isPaused: false
            }))
          }
        }, 1000)
        return {
          ...prev,
          hearts: newHearts,
          fails: newFails,
          stars: newStars,
          mistakesOnCurrentWord: newMistakesOnCurrentWord
        }
      })
    }
  }, [quizOptions, playSecondAudio, moveToNextWord, endGame])
  // Timer effect
  useEffect(() => {
    if (gameState.isGameOver || !game.quizParameters.activityTimeLimit || gameState.isPaused) return
    const timer = setInterval(() => {
      if (gameState.timeLeft <= 0) {
        // Handle timeout - count as wrong answer
        setGameState(prev => {
          const newMistakesOnCurrentWord = prev.mistakesOnCurrentWord + 1
          const newHearts = prev.hearts - 1
          const newFails = prev.fails + 1
          gameHeaderRef.current?.animateHeartLoss()
          let newStars = 3
          if (newFails >= 5) newStars = 1
          else if (newFails >= 3) newStars = 2
          // Store these values to use in the setTimeout
          const updatedHearts = newHearts
          const updatedMistakes = newMistakesOnCurrentWord
          // Use setTimeout to determine next steps
          setTimeout(() => {
            if (updatedHearts <= 0) { // If this was the last heart
              endGame()
            } else if (updatedMistakes >= 2) { 
              // This is the second mistake on this word
              // Show correct answer and play audio before proceeding
              setShowCorrectAnswer(true)
              // Find the correct option index
              const correctOptionIndex = quizOptions.findIndex(option => option.isCorrect)
              // Set the correct option as selected
              setGameState(prevState => ({ 
                ...prevState, 
                selectedOption: correctOptionIndex
              }))
              // Play the audio and then move to next word
              playSecondAudio().then(() => {
                setShowCorrectAnswer(false)
                moveToNextWord()
              })
            } else {
              // First mistake, reset the timer and allow another try
              setGameState(prevState => ({ 
                ...prevState, 
                timeLeft: game.quizParameters.activityTimeLimit,
                isPaused: false
              }))
            }
          }, 1000)
          return {
            ...prev,
            isPaused: true,
            hearts: newHearts,
            fails: newFails,
            stars: newStars,
            mistakesOnCurrentWord: newMistakesOnCurrentWord
          }
        })
      } else {
        setGameState(prev => ({ ...prev, timeLeft: prev.timeLeft - 1 }))
      }
    }, 1000)
    return () => clearInterval(timer)
  }, [
    endGame, 
    gameState.isGameOver, 
    game.quizParameters.activityTimeLimit, 
    gameState.timeLeft, 
    gameState.isPaused,
    moveToNextWord,
    playSecondAudio,
    quizOptions
  ])
  // If game is over, show the game over view
  if (gameState.isGameOver) {
    return (
      <GameOverView
        stars={gameState.stars}
        hearts={gameState.hearts}
        totalTime={gameState.totalTime}
        fails={gameState.fails}
        completedWords={gameState.completedWords}
        totalWords={game.wordPairs.length}
        onPlayAgain={restartGame}
        onExit={onGameEnd}
      />
    )
  }
  const currentWord = getCurrentWord()
  const progress = Math.round((gameState.currentWordIndex / game.wordPairs.length) * 100)
  return (
    <div className="flex flex-col items-center justify-center min-h-[70vh] w-full max-w-2xl mx-auto">
      <GameHeader
        ref={gameHeaderRef}
        hearts={gameState.hearts}
        timeLeft={gameState.timeLeft}
        timeLimit={game.quizParameters.activityTimeLimit}
        progress={progress}
        formatTime={formatTime}
      />
      <div className="mb-8 text-center">
        <div className="text-6xl font-bold mb-12 text-indigo-600">
          {currentWord.first}
        </div>
        {currentWord.sentence && !hideExampleSentences && (
          <div className="mt-2 text-gray-600 italic text-sm p-2 bg-gray-50 rounded-md">
            {currentWord.sentence}
          </div>
        )}
        {currentWord.sentence && (
          <div className="mt-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button 
                    variant="ghost" 
                    size="sm"
                    onClick={onToggleExampleSentences}
                  >
                    {hideExampleSentences ? (
                      <><EyeIcon className="h-4 w-4 mr-2" /> {t('showExamples')}</>
                    ) : (
                      <><EyeSlashIcon className="h-4 w-4 mr-2" /> {t('hideExamples')}</>
                    )}
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  {hideExampleSentences ? t('showExamples') : t('hideExamples')}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        )}
      </div>
      <div className="w-full space-y-4 mb-8 flex flex-col items-center justify-center">
        {quizOptions.map((option, index) => (
          <Button
            key={index}
            className={`w-full text-left justify-start text-2xl bold py-6 ${
              // If an option is selected, show it as green if correct, red if incorrect
              gameState.selectedOption === index
                ? option.isCorrect 
                  ? 'bg-green-100 hover:bg-green-200 text-green-800 border-green-500'
                  : 'bg-red-100 hover:bg-red-200 text-red-800 border-red-500'
                // If showing correct answer (after second mistake), highlight all options accordingly
                : showCorrectAnswer
                  ? option.isCorrect
                    ? 'bg-green-100 hover:bg-green-200 text-green-800 border-green-500'
                    : 'bg-red-100 hover:bg-red-200 text-red-800 border-red-500'
                  // Default styling for unselected options
                  : 'bg-white hover:bg-gray-50 text-gray-800 border-gray-300'
            } border-2`}
            variant="outline"
            disabled={gameState.selectedOption !== null || showCorrectAnswer}
            onClick={() => handleOptionSelect(index)}
          >
            {option.value}
          </Button>
        ))}
      </div>
      <Realistic onInit={handleConfettiInit} />
    </div>
  )
}
</file>

<file path="src/components/dictation/WordPairDisplay.tsx">
// src/components/dictation/WordPairDisplay.tsx
import { WordPair } from "@/lib/types"
interface WordPairDisplayProps {
  wordPairs: WordPair[]
  sourceLanguage: string
  targetLanguage: string
  hideSentences?: boolean
}
export function WordPairDisplay({ 
  wordPairs,
  sourceLanguage,
  targetLanguage,
  hideSentences = false
}: WordPairDisplayProps) {
  return (
    <div className="border rounded-lg overflow-hidden">
      <div className="grid grid-cols-2 gap-4 p-4 bg-gray-50 font-semibold">
        <div>{sourceLanguage}</div>
        <div>{targetLanguage}</div>
      </div>
      <div className="divide-y">
        {wordPairs.map((pair, index) => (
          <div key={index} className="grid grid-cols-2 gap-4 p-4">
            <div>{pair.first}</div>
            <div>{pair.second}</div>
            {!hideSentences && pair.sentence && (
              <div className="col-span-2 text-sm text-gray-600 mt-2">
                {pair.sentence}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="src/components/dictation/WordPairList.tsx">
// src/components/dictation/WordPairList.tsx
'use client'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { WordPair } from "@/lib/types"
import { PlusIcon, TrashIcon } from "@heroicons/react/24/outline"
import { FileUpload } from "./FileUpload"
import type { WordPairsList } from "@/lib/openai"
import { useTranslations } from 'next-intl'
interface WordPairListProps {
  wordPairs: WordPair[]
  sourceLanguage: string
  targetLanguage: string
  disabled?: boolean
  onChange: (wordPairs: WordPair[]) => void
  onFileUploadStart?: () => void
  onFileUploadComplete?: (data: WordPairsList) => void
  onFileUploadError?: (error: string) => void
}
export function WordPairList({ 
  wordPairs,
  sourceLanguage,
  targetLanguage,
  disabled = false,
  onChange,
  onFileUploadStart,
  onFileUploadComplete,
  onFileUploadError
}: WordPairListProps) {
  const t = useTranslations('Dictation.form')
  const tLang = useTranslations('Language')
  const handleAddPair = () => {
    onChange([...wordPairs, { first: '', second: '', sentence: '' }])
  }
  const handleRemovePair = (index: number) => {
    onChange(wordPairs.filter((_, i) => i !== index))
  }
  const handlePairChange = (index: number, field: keyof WordPair, value: string) => {
    const newPairs = [...wordPairs]
    newPairs[index] = { ...newPairs[index], [field]: value }
    onChange(newPairs)
  }
  return (
    <div className="space-y-4">
      {onFileUploadStart && onFileUploadComplete && onFileUploadError && (
        <FileUpload
          onStart={onFileUploadStart}
          onComplete={onFileUploadComplete}
          onError={onFileUploadError}
          disabled={disabled}
          sourceLanguage={sourceLanguage}
          targetLanguage={targetLanguage}
        />
      )}
      <div className="border rounded-lg overflow-hidden">
        <div className="grid grid-cols-[1fr,1fr,2fr,auto] gap-4 p-4 bg-gray-50 font-semibold">
          <div>{tLang(`languages.${sourceLanguage}`)}</div>
          <div>{tLang(`languages.${targetLanguage}`)}</div>
          <div>{t('exampleSentence')}</div>
          <div className="w-8"></div>
        </div>
        <div className="divide-y">
          {wordPairs.map((pair, index) => (
            <div key={index} className="grid grid-cols-[1fr,1fr,2fr,auto] gap-4 p-4">
              <Input
                value={pair.first}
                onChange={(e) => handlePairChange(index, 'first', e.target.value)}
                placeholder={t('sourceWord', { language: tLang(`languages.${sourceLanguage}`) })}
                disabled={disabled}
              />
              <Input
                value={pair.second}
                onChange={(e) => handlePairChange(index, 'second', e.target.value)}
                placeholder={t('targetWord', { language: tLang(`languages.${targetLanguage}`) })}
                disabled={disabled}
              />
              <Input
                value={pair.sentence || ''}
                onChange={(e) => handlePairChange(index, 'sentence', e.target.value)}
                placeholder={t('exampleSentence')}
                disabled={disabled}
              />
              <Button
                type="button"
                variant="ghost"
                size="icon"
                onClick={() => handleRemovePair(index)}
                disabled={disabled || wordPairs.length === 1}
              >
                <TrashIcon className="h-4 w-4" />
                <span className="sr-only">Remove pair</span>
              </Button>
            </div>
          ))}
        </div>
      </div>
      <Button
        type="button"
        variant="outline"
        size="sm"
        onClick={handleAddPair}
        disabled={disabled}
        className="w-full"
      >
        <PlusIcon className="h-4 w-4 mr-2" />
        {t('addWordPair')}
      </Button>
    </div>
  )
}
</file>

<file path="src/components/dictation/WriterGameClient.tsx">
'use client'
import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { DictationGame } from '@/lib/types'
import { GameView } from '@/components/dictation/GameView'
import { Button } from '@/components/ui/button'
import { ArrowLeftIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
interface WriterGameClientProps {
  game: DictationGame
}
export function WriterGameClient({ game }: WriterGameClientProps) {
  const searchParams = useSearchParams()
  const hideExamplesParam = searchParams.get('hideExamples')
  const [hideExampleSentences, setHideExampleSentences] = useState(
    hideExamplesParam === 'true' || hideExamplesParam === null
  )
  const [showBackButton, setShowBackButton] = useState(true)
  const router = useRouter()
  const t = useTranslations('Dictation.game')
  // Hide back button after 5 seconds
  useEffect(() => {
    if (showBackButton) {
      const timer = setTimeout(() => {
        setShowBackButton(false)
      }, 5000)
      return () => clearTimeout(timer)
    }
  }, [showBackButton])
  const handleGameEnd = () => {
    router.push(`/dictation/play/${game.id}`)
  }
  const handleBackClick = () => {
    router.back()
  }
  return (
    <div className="relative">
      {showBackButton && (
        <div className="absolute top-0 left-0 z-10 p-4 transition-opacity duration-300">
          <Button
            variant="outline"
            size="sm"
            onClick={handleBackClick}
            className="flex items-center gap-1"
          >
            <ArrowLeftIcon className="h-4 w-4" />
            {t('back')}
          </Button>
        </div>
      )}
      <GameView 
        game={game} 
        onGameEnd={handleGameEnd} 
        hideExampleSentences={hideExampleSentences}
        onToggleExampleSentences={() => setHideExampleSentences(prev => !prev)}
      />
    </div>
  )
}
</file>

<file path="src/components/dictation/WriterGameContainer.tsx">
'use client'
// DEPRECATED: This component has been replaced by WriterGameClient
// This file is kept for backward compatibility but should be removed in future updates
import { useState, useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { DictationGame } from '@/lib/types'
import { GameView } from '@/components/dictation/GameView'
import { Button } from '@/components/ui/button'
import { ArrowLeftIcon } from '@heroicons/react/24/outline'
import { useTranslations } from 'next-intl'
interface WriterGameContainerProps {
  game: DictationGame
}
export function WriterGameContainer({ game }: WriterGameContainerProps) {
  console.warn('WriterGameContainer is deprecated. Please use WriterGameClient instead.')
  const searchParams = useSearchParams()
  const hideExamplesParam = searchParams.get('hideExamples')
  const [hideExampleSentences, setHideExampleSentences] = useState(
    hideExamplesParam === 'true' || hideExamplesParam === null
  )
  const [showBackButton, setShowBackButton] = useState(true)
  const router = useRouter()
  const t = useTranslations('Dictation.game')
  // Hide back button after 5 seconds
  useEffect(() => {
    if (showBackButton) {
      const timer = setTimeout(() => {
        setShowBackButton(false)
      }, 5000)
      return () => clearTimeout(timer)
    }
  }, [showBackButton])
  const handleGameEnd = () => {
    router.push(`/dictation/play/${game.id}`)
  }
  const handleBackClick = () => {
    router.back()
  }
  return (
    <div className="relative">
      {showBackButton && (
        <div className="absolute top-0 left-0 z-10 p-4 transition-opacity duration-300">
          <Button
            variant="outline"
            size="sm"
            onClick={handleBackClick}
            className="flex items-center gap-1"
          >
            <ArrowLeftIcon className="h-4 w-4" />
            {t('back')}
          </Button>
        </div>
      )}
      <GameView 
        game={game} 
        onGameEnd={handleGameEnd} 
        hideExampleSentences={hideExampleSentences}
        onToggleExampleSentences={() => setHideExampleSentences(prev => !prev)}
      />
    </div>
  )
}
</file>

<file path="src/components/Footer/index.tsx">
import Link from 'next/link'
export function Footer() {
	return (
		<footer className="mt-auto py-6 border-t border-gray-200 bg-white/75 backdrop-blur-lg">
			<div className="container mx-auto px-4">
				<div className="flex flex-col sm:flex-row justify-between items-center gap-4">
					<div className="text-sm text-gray-500">
						© {new Date().getFullYear()} Dictation Master
					</div>
					<nav className="flex gap-6">
						<Link
							href="/privacy-policy"
							className="text-sm text-gray-500 hover:text-gray-700 transition-colors"
						>
							Privacy Policy
						</Link>
					</nav>
				</div>
			</div>
		</footer>
	)
}
</file>

<file path="src/components/Header/index.tsx">
"use client"
import Link from 'next/link'
import Image from 'next/image'
import { useSession } from 'next-auth/react'
import { handleSignOut } from '@/app/auth/actions'
import { LanguageSelector } from '@/components/LanguageSelector'
import { useTranslations } from 'next-intl'
/*
function getInitials(name: string | null | undefined) {
  if (!name) return '?'
  return name
    .split(' ')
    .map(part => part[0])
    .join('')
    .toUpperCase()
    .slice(0, 2)
}
*/
function UserButton() {
  const { data: session } = useSession()
  const t = useTranslations('Header')
  if (!session?.user) {
    return (
      <Link
        href="/auth/signin"
        className="relative rounded-full bg-gray-100 p-1 hover:bg-gray-200"
      >
        <div className="h-8 w-8 rounded-full bg-gray-300 flex items-center justify-center">
          <span className="sr-only">{t('signIn')}</span>
          <svg
            className="h-5 w-5 text-gray-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
            />
          </svg>
        </div>
      </Link>
    )
  }
  return (
    <div className="relative group">
      <Link
        href="/profile"
        className="relative rounded-full bg-gray-100 p-1 hover:bg-gray-200 block"
      >
        <div className="h-8 w-8 rounded-full bg-gray-300 overflow-hidden">
          {session.user.image ? (
            <Image
              src={session.user.image}
              alt={session.user.name || "User"}
              width={32}
              height={32}
              className="h-full w-full object-cover"
            />
          ) : (
            <div className="h-full w-full flex items-center justify-center">
              <span className="text-lg font-medium text-gray-600">
                {session.user.name?.charAt(0) || session.user.email?.charAt(0)}
              </span>
            </div>
          )}
        </div>
      </Link>
      <div className="absolute ltr:right-0 rtl:left-0 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200">
        <div className="px-4 py-2 text-sm text-gray-700 border-b border-gray-100">
          {session.user.name || session.user.email}
        </div>
        <Link
          href="/profile"
          className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
        >
          {t('profile')}
        </Link>
        <form action={handleSignOut}>
          <button
            type="submit"
            className="block w-full px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-100"
          >
            {t('signOut')}
          </button>
        </form>
      </div>
    </div>
  )
}
export function Header() {
  const t = useTranslations('Header')
  return (
    <header className="sticky top-0 z-50 w-full border-b border-gray-200 bg-white/75 backdrop-blur-lg">
      <div className="container mx-auto flex h-16 items-center justify-between px-4">
        <Link href="/" className="flex items-center">
          <Image
            src="/logo.svg"
            alt={t('appName')}
            width={32}
            height={32}
            className="h-8 w-auto"
          />
          <span className="font-semibold text-xl ltr:-ml-[5px] rtl:mr-[5px]">{t('appName')}</span>
        </Link>
        <div className="flex items-center gap-2">
          <LanguageSelector />
          {UserButton()}
        </div>
      </div>
    </header>
  )
}
</file>

<file path="src/components/ui/AdBlockDetector.tsx">
'use client'
import { useEffect, useState } from 'react'
export function AdBlockDetector() {
	const [isBlocked, setIsBlocked] = useState(false)
	useEffect(() => {
		const detectAdBlock = async () => {
			try {
				const testAd = document.createElement('div')
				testAd.className = 'adsbygoogle'
				testAd.style.height = '1px'
				testAd.style.position = 'absolute'
				testAd.style.left = '-999px'
				document.body.appendChild(testAd)
				// Wait briefly to see if the ad element gets hidden or removed
				await new Promise(resolve => setTimeout(resolve, 100))
				const isAdBlocked = !testAd.offsetHeight || 
					!testAd.clientHeight || 
					!document.querySelector('.adsbygoogle')
				setIsBlocked(isAdBlocked)
				testAd.remove()
			} catch (error) {
				setIsBlocked(true)
                console.log('error occured in adblock detector',error)
			}
		}
		detectAdBlock()
	}, [])
	if (!isBlocked) return null
	return (
		<div className="p-4 mb-4 text-sm text-amber-800 bg-amber-50 dark:bg-amber-900/10 dark:text-amber-400 rounded-lg">
			<p>
				{`We noticed you're using an ad blocker. We keep this site free by showing minimal, 
				non-intrusive ads. Please consider disabling your ad blocker to support us.`}
			</p>
		</div>
	)
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"
export { Button, buttonVariants }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
const DialogPortal = DialogPrimitive.Portal
const DialogClose = DialogPrimitive.Close
const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName
const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"
const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"
const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName
const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName
export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup
const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName
const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName
const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName
const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName
const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName
const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName
const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName
const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName
const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"
export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"
export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)
const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName
export { Label }
</file>

<file path="src/components/ui/popover.tsx">
"use client"
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"
const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverAnchor = PopoverPrimitive.Anchor
const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName
export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/select.tsx">
"use client"
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "@/lib/utils"
const Select = SelectPrimitive.Root
const SelectGroup = SelectPrimitive.Group
const SelectValue = SelectPrimitive.Value
const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName
const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName
const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName
const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName
const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName
const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 cursor-pointer",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName
const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName
export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"
function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}
export { Skeleton }
</file>

<file path="src/components/ui/sonner.tsx">
"use client"
import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"
type ToasterProps = React.ComponentProps<typeof Sonner>
const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()
  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}
export { Toaster }
</file>

<file path="src/components/ui/spinner.tsx">
import { cn } from "@/lib/utils"
interface SpinnerProps {
  className?: string
  size?: 'sm' | 'md' | 'lg'
}
export function Spinner({ className, size = 'md' }: SpinnerProps) {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8'
  }
  return (
    <div role="status">
      <svg
        className={cn(
          "animate-spin text-current",
          sizeClasses[size],
          className
        )}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </svg>
      <span className="sr-only">Loading...</span>
    </div>
  )
}
</file>

<file path="src/components/ui/switch.tsx">
"use client"
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"
const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform",
        "rtl:data-[state=checked]:translate-x-[-16px] rtl:data-[state=unchecked]:translate-x-0",
        "ltr:data-[state=checked]:translate-x-4 ltr:data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName
export { Switch }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"
export { Textarea }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "@/lib/utils"
const TooltipProvider = TooltipPrimitive.Provider
const Tooltip = TooltipPrimitive.Root
const TooltipTrigger = TooltipPrimitive.Trigger
const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName
export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/LanguageSelector.tsx">
'use client'
import { useTranslations } from 'next-intl'
import { useRouter } from 'next/navigation'
import { setUserLocale } from '@/lib/locale'
import { Globe } from 'lucide-react'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger
} from "@/components/ui/select"
export function LanguageSelector() {
  const t = useTranslations('Language')
  const router = useRouter()
  const handleLanguageChange = async (value: string) => {
    await setUserLocale(value as 'en' | 'he')
    router.refresh()
  }
  return (
    <Select onValueChange={handleLanguageChange}>
      <SelectTrigger className="w-12 text-center p-0">
        <Globe className="h-4 w-full" />
      </SelectTrigger>
      <SelectContent>
        <SelectItem value="en">{t('en')}</SelectItem>
        <SelectItem value="he">{t('he')}</SelectItem>
      </SelectContent>
    </Select>
  )
}
</file>

<file path="src/components/PostHogProvider.tsx">
'use client'
import posthog from 'posthog-js'
import { PostHogProvider as PHProvider } from 'posthog-js/react'
import { usePathname, useSearchParams } from 'next/navigation'
import { useEffect } from 'react'
import { usePostHogUser } from '@/hooks/usePostHogUser'
export function PostHogPageview(): React.ReactNode {
	const pathname = usePathname()
	const searchParams = useSearchParams()
	useEffect(() => {
		if (pathname) {
			let url = window.origin + pathname
			if (searchParams?.toString()) {
				url = url + `?${searchParams.toString()}`
			}
			posthog.capture('$pageview', {
				$current_url: url,
			})
		}
	}, [pathname, searchParams])
	return <></>
}
export function PostHogProvider({ children }: { children: React.ReactNode }) {
	// Use the hook for auto user identification
	usePostHogUser()
	useEffect(() => {
		posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
			api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
			person_profiles: 'identified_only',
			capture_pageview: false, // We'll capture pageviews manually
		})
	}, [])
	return (
		<PHProvider client={posthog}>
			<PostHogPageview />
			{children}
		</PHProvider>
	)
}
</file>

<file path="src/components/Providers.tsx">
'use client'
import { SessionProvider } from "next-auth/react"
import { Session } from "next-auth"
import { PostHogProvider } from "./PostHogProvider"
export function Providers({ children, session }: { children: React.ReactNode, session: Session | null }) {
  return (
    <SessionProvider session={session}>
      <PostHogProvider>
        {children}
      </PostHogProvider>
    </SessionProvider>
  )
}
</file>

<file path="src/hooks/usePostHogUser.tsx">
'use client'
import { useEffect } from 'react'
import { useSession } from 'next-auth/react'
import { identifyUser, resetUser } from '@/lib/posthog-utils'
/**
 * Hook to automatically identify users with PostHog when they log in
 * and reset identification when they log out
 */
export function usePostHogUser() {
	const { data: session } = useSession()
	useEffect(() => {
		if (session?.user) {
			// Identify the user in PostHog with their ID and properties
			identifyUser(
				// Use user ID or email as the distinct ID
				session.user.id || session.user.email || 'anonymous',
				{
					email: session.user.email,
					name: session.user.name,
					// Add any other user properties you want to track
					signedUp: new Date().toISOString(),
				}
			)
		} else {
			// Reset user identification when logged out
			resetUser()
		}
	}, [session])
	return null
}
</file>

<file path="src/i18n/config.ts">
export type Locale = (typeof locales)[number];
export const locales = ['en', 'he'] as const;
export const defaultLocale: Locale = 'en';
</file>

<file path="src/i18n/request.ts">
import { getUserLocale } from '@/lib/locale';
import {getRequestConfig} from 'next-intl/server';
import { defaultLocale } from './config';
export default getRequestConfig(async () => {
  const locale = await getUserLocale();
  let messages = null
  try {
    messages = (await import(`../../messages/${locale}.json`)).default
  } catch (error) {
    console.warn(`Could not load messages for locale: ${locale}, falling back to default locale: ${defaultLocale}`);
    console.error(error);
    messages = (await import(`../../messages/${defaultLocale}.json`)).default
  }
  return {
    locale,
    messages
  };
});
</file>

<file path="src/lib/server/tts.ts">
import { APP_URL } from '@/lib/server-constants'
/**
 * Get TTS URLs for a list of words using the TTS endpoint
 * @param words Array of words to generate TTS for
 * @param language Language code for TTS generation
 * @returns Record mapping each word to its TTS URL
 */
export async function getTTSUrls(words: string[], language: string): Promise<Record<string, string>> {
  const response = await fetch(`${APP_URL}/api/dictation/tts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ words, language })
  })
  const data = await response.json()
  if (!data.success) {
    throw new Error('Failed to generate TTS')
  }
  // Create a map of word to URL
  return data.results.reduce((acc: Record<string, string>, item: { word: string, url: string }) => {
    acc[item.word] = item.url
    return acc
  }, {})
}
</file>

<file path="src/lib/auth.ts">
import NextAuth from "next-auth"
import GoogleProvider from "next-auth/providers/google"
import CredentialsProvider from "next-auth/providers/credentials"
import { getAuth, signInWithEmailAndPassword, signInWithCredential, GoogleAuthProvider, setPersistence, browserLocalPersistence } from "firebase/auth"
import { initFirebaseApp } from "./firebase"
export const {
  handlers/*: { GET, POST }*/,
  auth,
  signIn,
  signOut,
  unstable_update,
} = NextAuth({
  secret: process.env.AUTH_SECRET,
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 24 * 60 * 60, // 24 hours
  },
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        const email = credentials?.email as string
        const password = credentials?.password as string
        if (!email || !password) return null
        try {
          const auth = getAuth(initFirebaseApp())
          const userCredential = await signInWithEmailAndPassword(
            auth,
            email,
            password
          )
          const user = userCredential.user
          if (user) {
            return {
              id: user.uid,
              email: user.email,
              name: user.displayName,
              image: user.photoURL,
            }
          }
          return null
        } catch (error) {
          console.error("Error:", error)
          return null
        }
      }
    }),
  ],
  pages: {
    signIn: "/auth/signin",
    error: "/auth/error",
  },
  callbacks: {
    async signIn({ user, account }) {
      if (account?.provider === "google") {
        try {
          const auth = getAuth(initFirebaseApp())
          // Set persistence to LOCAL to persist the Firebase session
          await setPersistence(auth, browserLocalPersistence)
          // Create a Google credential with the token
          const credential = GoogleAuthProvider.credential(
            account.id_token,
            account.access_token
          )
          // Sign in to Firebase with the credential
          const result = await signInWithCredential(auth, credential)
          // Update the Next Auth user ID to match Firebase
          user.id = result.user.uid
          return true
        } catch (error) {
          console.error("Error syncing with Firebase:", error)
          return false
        }
      }
      return true
    },
    async redirect({ url, baseUrl }) {
      // Allows relative callback URLs
      if (url.startsWith("/")) return `${baseUrl}${url}`
      // Allows callback URLs on the same origin
      else if (new URL(url).origin === baseUrl) return url
      return baseUrl
    },
    async jwt({ token, user, account, trigger, session }) {
      //console.log('JWT Callback:', { trigger, hasUser: !!user, hasSession: !!session })
      if (user) {
        // Always use the user object's ID as it will be the Firebase UID
        token.id = user.id
        if (account?.provider === "google") {
          token.name = user.name
          token.email = user.email
          token.picture = user.image
        }
      }
      // Handle updates to the session
      if (trigger === "update" && session?.user) {
        console.log('Updating token with:', session.user)
        token.name = session.user.name
        token.picture = session.user.image
      }
      //console.log('Returning token:', token)
      return token
    },
    async session({ session, token }) {
      if (session.user) {
        // Always use the token's ID which will be the Firebase UID
        session.user.id = token.id as string
        session.user.name = token.name
        session.user.email = token.email as string
        session.user.image = token.picture as string | null
      }
      return session
    }
  },
})
</file>

<file path="src/lib/client-constants.ts">
export const APP_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
</file>

<file path="src/lib/fileUtils.ts">
import { WordPair } from './types'
export async function parseWordPairsFile(file: File): Promise<{ wordPairs: WordPair[], error?: string }> {
  try {
    const text = await file.text()
    const lines = text.split('\n')
    const wordPairs: WordPair[] = []
    // Skip header row if CSV
    const startIndex = file.type === 'text/csv' ? 1 : 0
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i].trim()
      if (!line) continue
      let parts: string[]
      if (file.type === 'text/csv') {
        // Handle CSV format (source_word,target_word,example_sentence)
        parts = line.split(',').map(part => part.trim())
      } else {
        // Handle TXT format (source_word\ttarget_word\texample_sentence)
        parts = line.split('\t').map(part => part.trim())
      }
      if (parts.length < 2) {
        return { 
          wordPairs: [], 
          error: `Invalid format at line ${i + 1}. Each line must have at least two words.` 
        }
      }
      wordPairs.push({
        first: parts[0],
        second: parts[1],
        sentence: parts[2] || ''
      })
    }
    if (wordPairs.length === 0) {
      return { wordPairs: [], error: 'No valid word pairs found in file' }
    }
    if (wordPairs.length > 50) {
      return { wordPairs: [], error: 'Maximum of 50 word pairs allowed' }
    }
    return { wordPairs }
  } catch (error) {
    console.error('Error parsing file:', error)
    return { wordPairs: [], error: 'Failed to parse file' }
  }
}
</file>

<file path="src/lib/firebase-admin.ts">
import { getApps, initializeApp, cert } from 'firebase-admin/app'
export function initAdminApp() {
  if (getApps().length) return getApps()[0]
  // Try to parse service account from environment variable
  let serviceAccount
  try {
    const serviceAccountStr = process.env.FIREBASE_SERVICE_ACCOUNT_KEY
    if (serviceAccountStr) {
      serviceAccount = JSON.parse(serviceAccountStr)
    } else {
      // Fallback to individual environment variables
      serviceAccount = {
        type: 'service_account',
        project_id: process.env.FIREBASE_PROJECT_ID,
        private_key: (process.env.FIREBASE_PRIVATE_KEY || '').replace(/\\n/g, '\n'),
        client_email: process.env.FIREBASE_CLIENT_EMAIL,
      }
    }
  } catch (error) {
    console.error('Error parsing service account:', error)
    throw new Error('Invalid service account configuration')
  }
  if (!serviceAccount.project_id) {
    throw new Error('Missing required service account field: project_id')
  }
  return initializeApp({
    credential: cert(serviceAccount)
  })
}
</file>

<file path="src/lib/firebase.ts">
import { getApps, initializeApp } from "firebase/app"
import { getAnalytics } from "firebase/analytics"
import { GoogleAuthProvider } from "firebase/auth"
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID
}
export function initFirebaseApp() {
  if (getApps().length) return getApps()[0]
  const app = initializeApp(firebaseConfig)
  if (typeof window !== "undefined") {
    getAnalytics(app)
  }
  return app
}
// Configure Google Auth Provider with the same client ID
export const googleProvider = new GoogleAuthProvider()
googleProvider.setCustomParameters({
  client_id: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID!
})
</file>

<file path="src/lib/game.ts">
import { APP_URL } from './server-constants'
import { DictationGame } from './types'
import { cookies } from 'next/headers'
export async function getGame(id: string): Promise<DictationGame> {
  const cookieStore = await cookies()
  const gamePlayUrl = `${APP_URL}/api/dictation/play/${id}`
  try {
    const response = await fetch(gamePlayUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        Cookie: cookieStore.toString()
      },
      cache: 'no-store',
    })
    if (!response.ok) {
      throw new Error('Failed to fetch game')
    }
    const game = await response.json()
    return game
  } catch (error) {
    console.error('Error fetching game:', error)
    throw new Error(`Failed to fetch game ${APP_URL}/api/dictation/play/${id}`)
  }
}
</file>

<file path="src/lib/locale.ts">
'use server';
import {cookies} from 'next/headers';
import {Locale, defaultLocale, locales} from '@/i18n/config';
// In this example the locale is read from a cookie. You could alternatively
// also read it from a database, backend service, or any other source.
const COOKIE_NAME = 'NEXT_LOCALE';
export async function getUserLocale() {
  const cookieStore = await cookies();
  const userLocale = cookieStore.get(COOKIE_NAME)?.value || defaultLocale;
  // If the exact locale is supported, use it
  if (locales.includes(userLocale as Locale)) {
    return userLocale;
  }
  // Otherwise, try to find a base locale match (e.g., 'en-gb' -> 'en')
  const baseLocale = userLocale.split('-')[0];
  if (locales.includes(baseLocale as Locale)) {
    return baseLocale;
  }
  // If no match is found, fallback to the default locale
  return defaultLocale;
}
export async function setUserLocale(locale: Locale) {
  const cookieStore = await cookies();
  cookieStore.set(COOKIE_NAME, locale);
}
</file>

<file path="src/lib/metadata.ts">
import { Metadata } from 'next'
export const defaultMetadata = {
  en: {
    title: 'Dictation Master',
    description: 'Create and manage language learning games through dictation exercises. Enhance your language skills with interactive audio-based learning.',
    keywords: ['language learning', 'dictation', 'education', 'audio learning', 'vocabulary practice'],
  },
  he: {
    title: 'מאסטר הכתבה',
    description: 'צור ונהל משחקי לימוד שפה באמצעות תרגילי הכתבה. שפר את כישורי השפה שלך עם למידה אינטראקטיבית מבוססת שמע.',
    keywords: ['לימוד שפה', 'הכתבה', 'חינוך', 'למידה קולית', 'תרגול אוצר מילים'],
  }
}
export const siteConfig = {
  name: 'Dictation Masters',
  url: 'https://acedzn.xyz',
  ogImage: '/og-image.png', 
  author: 'Dictation Masters Team',
  twitter: '@dictationmaster',
}
export function generateMetadata(
  locale: string = 'en',
  {
    title,
    description,
    path = '',
    image,
  }: {
    title?: string
    description?: string
    path?: string
    image?: string
  } = {}
): Metadata {
  const localeData = defaultMetadata[locale as keyof typeof defaultMetadata] || defaultMetadata.en
  const fullTitle = title 
    ? `${title} | ${siteConfig.name}`
    : localeData.title
  return {
    title: fullTitle,
    description: description || localeData.description,
    keywords: localeData.keywords,
    authors: [{ name: siteConfig.author }],
    metadataBase: new URL(siteConfig.url),
    alternates: {
      canonical: path,
    },
    openGraph: {
      type: 'website',
      locale: locale,
      url: path,
      title: fullTitle,
      description: description || localeData.description,
      siteName: siteConfig.name,
      images: [{
        url: image || siteConfig.ogImage,
        width: 1200,
        height: 630,
        alt: fullTitle,
      }],
    },
    twitter: {
      card: 'summary_large_image',
      title: fullTitle,
      description: description || localeData.description,
      images: [image || siteConfig.ogImage],
      creator: siteConfig.twitter,
    },
    robots: {
      index: true,
      follow: true,
      googleBot: {
        index: true,
        follow: true,
        'max-video-preview': -1,
        'max-image-preview': 'large',
        'max-snippet': -1,
      },
    },
  }
}
</file>

<file path="src/lib/openai.ts">
'use server'
import OpenAI from 'openai'
import { z } from 'zod'
import { zodResponseFormat } from 'openai/helpers/zod'
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 55000, // 55 seconds timeout
  maxRetries: 2, // Limit retries to avoid hitting the timeout
})
const WordPairsList = z.object({
  title: z.string(),
  description: z.string().optional(),
  wordPairs: z.array(
    z.object({
      first: z.string(),
      second: z.string(),
      sentence: z.string(),
      imagePrompt: z.string(),
    }),
  ),
})
export type WordPairsList = z.infer<typeof WordPairsList>
export async function extractWordPairsFromImage(
  base64Image: string,
  firstLanguage: string,
  secondLanguage: string,
): Promise<WordPairsList> {
  // Remove the data URL prefix if present
  const base64Data = base64Image.replace(/^data:image\/\w+;base64,/, '')
  const imagePrompt = `Extract word pairs from image. For each: 'first' in ${firstLanguage}, 'second' in ${secondLanguage}, ${secondLanguage} 'sentence' using word, 'imagePrompt' (always in English) for visualization. Use exact words if present. Only translate if no translation found. Include multiple ${firstLanguage} words if given for one ${secondLanguage} word. make sure to use the words exactly as they appear in the image. Return JSON array. double check that you have all the words, no matter how much words are in the image. If you are not sure, Check the image again. if there are words only in one of the specified languages, make sure to use and TRANSLATE the words to the other language. Also, add a relevant title and interesting description, both in ${firstLanguage}, related to the topic of the words, cool, and SEO friendly.`
  console.log('extractWordPairsFromImage',{ firstLanguage, secondLanguage, imagePrompt })
  const response = await openai.chat.completions.create({
    model: 'gpt-4o-2024-08-06',
    response_format: zodResponseFormat(WordPairsList, 'word_pairs'),
    messages: [
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: imagePrompt,
          },
          {
            type: 'image_url',
            image_url: {
              url: `data:image/jpeg;base64,${base64Data}`,
            },
          },
        ],
      },
    ],
    max_tokens: 3500,
  })
  const content = response.choices[0].message.content
  if (!content) {
    throw new Error('No content in the response')
  }
  try {
    const result = JSON.parse(content)
    return result
  } catch (error) {
    console.error('Error parsing OpenAI response:', error)
    throw new Error('Failed to parse word pairs from the image')
  }
}
export async function extractWordPairsFromText(
  text: string,
  firstLanguage: string,
  secondLanguage: string,
): Promise<WordPairsList> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    response_format: zodResponseFormat(WordPairsList, 'word_pairs'),
    messages: [
      {
        role: 'user',
        content: `Extract word pairs from the following text. For each pair: 'first' in ${firstLanguage}, 'second' in ${secondLanguage}, ${secondLanguage} 'sentence' using the word, 'imagePrompt' (always in English) for visualization. Use exact words if present. Only translate if no translation is given. Include multiple ${firstLanguage} words if given for one ${secondLanguage} word. Make sure to use the words exactly as they appear in the text. Also,  add a relevant title and interesting description, both in ${firstLanguage}, related to the topic of the text words, cool, and SEO friendly. \n\nText:\n${text}`,
      },
    ],
    max_tokens: 3500,
  })
  const content = response.choices[0].message.content
  if (!content) {
    throw new Error('No content in the response')
  }
  try {
    const result = JSON.parse(content)
    return result
  } catch (error) {
    console.error('Error parsing OpenAI response:', error)
    throw new Error('Failed to parse word pairs from the text')
  }
}
</file>

<file path="src/lib/posthog-utils.ts">
import posthog from 'posthog-js'
/**
 * Identifies a user in PostHog when they log in
 * 
 * @param userId The unique identifier for the user
 * @param userProperties Optional properties to associate with the user
 */
export const identifyUser = (
	userId: string,
	userProperties?: Record<string, any>
) => {
	if (typeof window !== 'undefined') {
		posthog.identify(userId, userProperties)
	}
}
/**
 * Resets the current user in PostHog when they log out
 */
export const resetUser = () => {
	if (typeof window !== 'undefined') {
		posthog.reset()
	}
}
/**
 * Track a custom event with PostHog
 * 
 * @param eventName Name of the event to track
 * @param properties Optional properties to include with the event
 */
export const trackEvent = (
	eventName: string,
	properties?: Record<string, any>
) => {
	if (typeof window !== 'undefined') {
		posthog.capture(eventName, properties)
	}
}
/**
 * Track user onboarding progress
 * 
 * @param step The onboarding step name
 * @param properties Additional properties to track
 */
export const trackOnboardingStep = (
	step: string,
	properties?: Record<string, any>
) => {
	trackEvent('onboarding_step', {
		step,
		...properties
	})
}
/**
 * Set one or more user properties
 * 
 * @param properties Properties to set for the identified user
 */
export const setUserProperties = (properties: Record<string, any>) => {
	if (typeof window !== 'undefined') {
		posthog.people.set(properties)
	}
}
/**
 * Track feature usage
 * 
 * @param feature The feature name
 * @param properties Additional properties
 */
export const trackFeatureUsage = (
	feature: string,
	properties?: Record<string, any>
) => {
	trackEvent('feature_used', {
		feature,
		...properties
	})
}
</file>

<file path="src/lib/posthog.ts">
import { PostHog } from 'posthog-node'
/**
 * Creates and returns a PostHog client for server-side usage
 */
export default function PostHogClient() {
	const posthogClient = new PostHog(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
		host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
		flushAt: 1,
		flushInterval: 0
	})
	return posthogClient
}
/**
 * Helper function to capture server-side events with proper shutdown
 * 
 * @param distinctId User's distinct ID (user ID or anonymous ID)
 * @param event Event name to capture
 * @param properties Optional properties to include with the event
 */
export async function captureServerEvent(
	distinctId: string,
	event: string,
	properties?: Record<string, any>
) {
	const posthog = PostHogClient()
	try {
		await posthog.capture({
			distinctId,
			event,
			properties
		})
	} finally {
		// Always ensure we shut down the client
		await posthog.shutdown()
	}
}
/**
 * Helper function to get feature flags for a user on the server
 * 
 * @param distinctId User's distinct ID
 * @returns Object containing all feature flags for the user
 */
export async function getServerFeatureFlags(distinctId: string) {
	const posthog = PostHogClient()
	try {
		return await posthog.getAllFlags(distinctId)
	} finally {
		// Always ensure we shut down the client
		await posthog.shutdown()
	}
}
</file>

<file path="src/lib/server-constants.ts">
export const APP_URL = process.env.APP_URL || process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
</file>

<file path="src/lib/storage.ts">
import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "firebase/storage"
import { FirebaseError } from 'firebase/app'
import { initFirebaseApp } from "./firebase"
const storage = getStorage(initFirebaseApp())
export async function uploadProfileImage(userId: string, file: File) {
  try {
    // Create a reference to the profile image
    const storageRef = ref(storage, `users/${userId}/profile.${file.name.split('.').pop()}`)
    // Upload the file
    await uploadBytes(storageRef, file)
    // Get the download URL
    const downloadURL = await getDownloadURL(storageRef)
    return { success: true, url: downloadURL }
  } catch (error) {
    console.error("Error uploading image:", error)
    return { success: false, error: error instanceof FirebaseError ? error.message : 'Unknown error occurred' }
  }
}
export async function deleteProfileImage(userId: string, imageUrl: string) {
  try {
    // Extract the path from the URL
    const path = imageUrl.split('/o/')[1].split('?')[0]
    const decodedPath = decodeURIComponent(path)
    const storageRef = ref(storage, decodedPath)
    await deleteObject(storageRef)
    return { success: true }
  } catch (error) {
    console.error("Error deleting image:", error)
    return { success: false, error: error instanceof FirebaseError ? error.message : 'Unknown error occurred' }
  }
}
</file>

<file path="src/lib/types.ts">
import { Timestamp } from 'firebase-admin/firestore'
export interface WordPair {
  first: string
  second: string
  sentence?: string
  firstAudioUrl?: string
  secondAudioUrl?: string
}
export interface QuizParameters {
  globalTimeLimit: number
  globalLivesLimit: number
  activityTimeLimit: number
  quizModeEnabled: boolean
}
export interface DictationGame {
  id?: string
  userId: string
  title: string
  description?: string
  sourceLanguage: string
  targetLanguage: string
  wordPairs: WordPair[]
  quizParameters: QuizParameters
  createdAt?: Date
  updatedAt?: Date
}
export interface GameStructure {
  slides: Array<{
    type: 'intro' | 'dictation' | 'outro'
    layers: Array<{
      id?: string
      type: 'txt' | 'bg'
      info?: string
      transform?: number[]
    }>
    activities?: Array<{
      shapes: Array<{
        id: string
        settings: {
          textAnswerArray: string[]
          isUsingSpeakingMode: boolean
        }
      }>
    }>
  }>
}
export interface FirebaseGame {
  id: string
  title: string
  description?: string
  sourceLanguage: string
  targetLanguage: string
  wordPairs: Array<{
    first: string
    second: string
    sentence?: string
  }>
  createdAt: Timestamp
  isPublic: boolean
  userId: string
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
export const SUPPORTED_LANGUAGES = [
  { code: 'he', name: 'Hebrew' },
  { code: 'en', name: 'English' },
  /*
  { code: 'zh', name: 'Mandarin Chinese' },
  { code: 'hi', name: 'Hindi' },
  { code: 'es', name: 'Spanish' },
  { code: 'fr', name: 'French' },
  { code: 'ar', name: 'Arabic' },
  { code: 'bn', name: 'Bengali' },
  { code: 'ru', name: 'Russian' },
  { code: 'pt', name: 'Portuguese' },
  { code: 'id', name: 'Indonesian' },
  */
] as const
export function getLanguageNameFromCode(code: string): string {
  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === code)
  return language?.name || code
}
export function getLanguageCodeFromName(name: string): string {
  const language = SUPPORTED_LANGUAGES.find(lang => lang.name === name)
  return language?.code || name
}
</file>

<file path="src/types/rtl-detect.d.ts">
declare module 'rtl-detect' {
  export function getLangDir(locale: string): 'rtl' | 'ltr';
  export function isRtlLang(locale: string): boolean;
  export function getLangList(): string[];
}
</file>

<file path="src/middleware.ts">
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { auth } from "./lib/auth"
// Protected routes that require authentication
const protectedRoutes = ['/dictation/create']
export const config = {
  matcher: [
    // Protected routes
    '/dictation/create',
    // Auth routes
    '/auth/:path*'
  ]
}
export async function middleware(request: NextRequest) {
  const session = await auth()
  const isAuthPage = request.nextUrl.pathname.startsWith("/auth")
  const isApiAuthRoute = request.nextUrl.pathname.startsWith("/api/auth")
  const isProtectedRoute = protectedRoutes.some(route => 
    request.nextUrl.pathname.startsWith(route)
  )
  // Allow API auth routes to pass through
  if (isApiAuthRoute) {
    return NextResponse.next()
  }
  // Redirect to home if authenticated user tries to access auth pages
  if (isAuthPage && session) {
    return NextResponse.redirect(new URL("/", request.url))
  }
  // Redirect to login if unauthenticated user tries to access protected pages
  if (isProtectedRoute && !session) {
    let from = request.nextUrl.pathname
    if (request.nextUrl.search) {
      from += request.nextUrl.search
    }
    return NextResponse.redirect(
      new URL(`/auth/signin?from=${encodeURIComponent(from)}`, request.url)
    )
  }
  return NextResponse.next()
}
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "dictation-master-001",
    "dictation-masters-prod": "dictation-master-001"
  },
  "targets": {},
  "etags": {}
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
apphosting.yaml

.firebase/
firebase-debug.log
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="database.rules.json">
{
  /* Visit https://firebase.google.com/docs/database/security to learn more about security rules. */
  "rules": {
    ".read": false,
    ".write": false
  }
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.config({
    extends: ["next/core-web-vitals", "next/typescript"],
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
    },
  })
];

export default eslintConfig;
</file>

<file path="firebase.json">
{
  "storage": {
    "rules": "storage.rules"
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}
</file>

<file path="firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "dictation_games",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": []
}
</file>

<file path="firestore.rules">
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user is the owner of the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Rules for dictation_games collection
    match /dictation_games/{gameId} {
      // Allow reading if:
      // - The game is public, OR
      // - The user is the owner
      allow read: if resource.data.isPublic == true || 
                   isOwner(resource.data.userId);
      
      // Allow creation if:
      // - User is authenticated
      // - The userId in the document matches the authenticated user
      allow create: if isAuthenticated() && 
                     request.resource.data.userId == request.auth.uid;
      
      // Allow updates if:
      // - User is the owner
      // - Not trying to change the userId
      allow update: if isOwner(resource.data.userId) && 
                     request.resource.data.userId == resource.data.userId;
      
      // Allow deletion if user is the owner
      allow delete: if isOwner(resource.data.userId);
    }
  }
}
</file>

<file path="next.config.js">
const withNextIntl = require('next-intl/plugin')();
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
        pathname: '/a/**',
      },
      {
        protocol: 'https',
        hostname: 'firebasestorage.googleapis.com',
      },
    ],
  },
}
module.exports = withNextIntl(nextConfig)
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
const nextConfig: NextConfig = {
  /* config options here */
};
export default nextConfig;
</file>

<file path="package.json">
{
  "name": "dictation-master",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth/firebase-adapter": "^2.7.4",
    "@heroicons/react": "^2.2.0",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "elevenlabs": "^1.50.4",
    "firebase": "^11.2.0",
    "firebase-admin": "^13.0.2",
    "framer-motion": "^11.0.8",
    "lucide-react": "^0.473.0",
    "motion": "^12.0.1",
    "next": "15.1.5",
    "next-auth": "^5.0.0-beta.25",
    "next-intl": "^3.26.3",
    "next-themes": "^0.4.4",
    "openai": "^4.79.1",
    "posthog-js": "^1.229.5",
    "posthog-node": "^4.10.1",
    "react": "^19.0.0",
    "react-canvas-confetti": "^2.0.7",
    "react-dom": "^19.0.0",
    "react-hot-toast": "^2.5.1",
    "rtl-detect": "^1.1.2",
    "sonner": "^1.7.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19.0.7",
    "@types/react-dom": "^19.0.3",
    "eslint": "^9",
    "eslint-config-next": "15.1.5",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5",
    "cursor-tools": "latest"
  }
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="README.md">
# Getting Started with Dictation Manager

This guide will help you set up the Dictation Manager application for development or personal use.

## Prerequisites

Before installing Dictation Manager, ensure you have the following:

- Node.js (version 18 or higher)
- npm, yarn, or pnpm package manager
- Git (for cloning the repository)
- Firebase account (for database and authentication)

## Installation

### 1. Clone the Repository

```bash
git clone https://github.com/AceDZN/dictation-master.git
cd dictation-manager
```

### 2. Install Dependencies

Using npm:
```bash
npm install
```

Using yarn:
```bash
yarn install
```

Using pnpm:
```bash
pnpm install
```

### 3. Configure Firebase

1. Create a new project in the [Firebase Console](https://console.firebase.google.com/)
2. Enable Authentication (Email/Password and Google provider)
3. Create a Firestore database
4. Set up Storage

### 4. Configure Environment Variables

Create a `.env.local` file in the root directory of the project with the following variables:

```
# Firebase Configuration
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_auth_domain
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_storage_bucket
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# Firebase Admin SDK (for server-side operations)
FIREBASE_ADMIN_PROJECT_ID=your_project_id
FIREBASE_ADMIN_CLIENT_EMAIL=your_client_email
FIREBASE_ADMIN_PRIVATE_KEY=your_private_key

# Next Auth Configuration
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your_secret

# Optional: OpenAI API Key (for content generation)
OPENAI_API_KEY=your_openai_api_key
```

To obtain these values:

1. Firebase Web SDK config can be found in your Firebase project settings
2. For the Firebase Admin SDK, create a service account in the Firebase Console and download the JSON file

### 5. Security Rules

Configure Firebase security rules for Firestore and Storage. Sample rules are provided in:

- `firestore.rules` - For Firestore database rules
- `storage.rules` - For Firebase Storage rules

Deploy these rules using the Firebase CLI:

```bash
firebase deploy --only firestore:rules,storage
```

## Running the Application

### Development Mode

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

The application will be available at [http://localhost:3000](http://localhost:3000).

### Production Build

```bash
npm run build
npm start
# or
yarn build
yarn start
# or
pnpm build
pnpm start
```

## Firebase Emulator (Optional)

For local development without affecting your production Firebase instance:

1. Install Firebase CLI:
```bash
npm install -g firebase-tools
```

2. Login to Firebase:
```bash
firebase login
```

3. Start the Firebase emulator:
```bash
firebase emulators:start
```

4. Update your `.env.local` to point to the emulator:
```
NEXT_PUBLIC_FIREBASE_EMULATOR_HOST=localhost
NEXT_PUBLIC_FIREBASE_AUTH_EMULATOR_PORT=9099
NEXT_PUBLIC_FIRESTORE_EMULATOR_PORT=8080
```

## Next Steps

After setting up the application:

1. Create an account through the application
2. Create your first dictation game
3. Explore the features and customize your experience

For detailed usage instructions, refer to the [User Guide](./user-guide.md).
</file>

<file path="storage.rules">
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    match /users/{userId}/{allPaths=**} {
      allow read: if true;
      allow write: if request.auth != null;
    }
  }
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";
export default {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		keyframes: {
  			'bounce-slow': {
  				'0%, 100%': { transform: 'translateY(0)' },
  				'50%': { transform: 'translateY(-10px)' }
  			}
  		},
  		animation: {
  			'bounce-slow': 'bounce-slow 2s ease-in-out infinite'
  		},
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		fontFamily: {
  			alef: ['var(--font-alef)'],
  		},
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vercel.json">
{
  "functions": {
    "src/app/api/**/*": {
      "maxDuration": 60
    }
  }
}
</file>

</files>
